"""
Ansible Full System Recreation Generator
Generates comprehensive Ansible playbooks to fully recreate a system
"""

import json
import logging
import os
import re
import hashlib
from typing import Dict, List, Any, Optional

import yaml

logger = logging.getLogger(__name__)


class AnsibleFullGenerator:
    """Generates comprehensive Ansible playbooks for full system recreation"""

    def __init__(self, analysis_data: Dict[str, Any]):
        self.data = analysis_data
        self.hostname = analysis_data.get('hostname', 'server')
        self.os_info = analysis_data.get('os_info', {})

    def generate(self, output_dir: str) -> str:
        """Generate all Ansible files for full system recreation"""
        ansible_dir = output_dir

        # Create directory structure
        dirs = [
            'roles/base/tasks', 'roles/base/handlers', 'roles/base/defaults', 'roles/base/files', 'roles/base/templates',
            'roles/users/tasks', 'roles/users/handlers', 'roles/users/defaults', 'roles/users/files', 'roles/users/templates',
            'roles/groups/tasks', 'roles/groups/defaults',
            'roles/packages/tasks', 'roles/packages/handlers', 'roles/packages/defaults',
            'roles/services/tasks', 'roles/services/handlers', 'roles/services/defaults', 'roles/services/files',
            'roles/firewall/tasks', 'roles/firewall/handlers', 'roles/firewall/defaults',
            'roles/mounts/tasks', 'roles/mounts/defaults', 'roles/mounts/files',
            'roles/directories/tasks', 'roles/directories/defaults',
            'roles/docker/tasks', 'roles/docker/handlers', 'roles/docker/defaults', 'roles/docker/files', 'roles/docker/templates',
            'roles/cron/tasks', 'roles/cron/defaults', 'roles/cron/files',
            'roles/network/tasks', 'roles/network/handlers', 'roles/network/defaults', 'roles/network/files', 'roles/network/templates',
            'roles/configs/tasks', 'roles/configs/handlers', 'roles/configs/defaults', 'roles/configs/files', 'roles/configs/templates',
            'group_vars', 'host_vars', 'files', 'templates'
        ]

        for d in dirs:
            os.makedirs(os.path.join(ansible_dir, d), exist_ok=True)

        # Generate all files
        self._generate_inventory(ansible_dir)
        self._generate_ansible_cfg(ansible_dir)
        self._generate_site_playbook(ansible_dir)
        self._generate_group_vars(ansible_dir)
        self._generate_host_vars(ansible_dir)

        # Generate roles
        self._generate_base_role(ansible_dir)
        self._generate_users_role(ansible_dir)
        self._generate_groups_role(ansible_dir)
        self._generate_packages_role(ansible_dir)
        self._generate_services_role(ansible_dir)
        self._generate_firewall_role(ansible_dir)
        self._generate_mounts_role(ansible_dir)
        self._generate_directories_role(ansible_dir)
        self._generate_docker_role(ansible_dir)
        self._generate_cron_role(ansible_dir)
        self._generate_network_role(ansible_dir)
        self._generate_configs_role(ansible_dir)

        # Generate helper scripts
        self._generate_helper_scripts(ansible_dir)

        logger.info(f"Full Ansible configuration generated in: {ansible_dir}")
        return ansible_dir

    def _generate_inventory(self, output_dir: str) -> None:
        """Generate inventory file"""
        content = f'''# Ansible Inventory - Full System Recreation
# Generated by System Analyzer for: {self.hostname}

[target_servers]
{self.hostname} ansible_host={{{{ target_host }}}} ansible_user={{{{ ansible_user }}}}

[target_servers:vars]
ansible_python_interpreter=/usr/bin/python3
ansible_ssh_private_key_file={{{{ ssh_private_key_file | default("~/.ssh/id_rsa") }}}}
ansible_become=yes
ansible_become_method=sudo

# Uncomment for password-based auth
# ansible_ssh_pass={{{{ ssh_password }}}}
# ansible_become_pass={{{{ become_password }}}}
'''

        with open(os.path.join(output_dir, 'inventory'), 'w') as f:
            f.write(content)

    def _generate_ansible_cfg(self, output_dir: str) -> None:
        """Generate ansible.cfg"""
        content = '''[defaults]
inventory = inventory
remote_user = root
host_key_checking = False
retry_files_enabled = False
gathering = smart
fact_caching = jsonfile
fact_caching_connection = .ansible_facts_cache
fact_caching_timeout = 3600
stdout_callback = yaml
callback_whitelist = timer, profile_tasks
forks = 10
timeout = 30

[privilege_escalation]
become = True
become_method = sudo
become_user = root
become_ask_pass = False

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no

[diff]
always = True
context = 3
'''

        with open(os.path.join(output_dir, 'ansible.cfg'), 'w') as f:
            f.write(content)

    def _generate_site_playbook(self, output_dir: str) -> None:
        """Generate main site.yml playbook"""
        playbook = [
            {
                'name': f'Full System Recreation - {self.hostname}',
                'hosts': 'target_servers',
                'become': True,
                'gather_facts': True,
                'vars_files': [
                    'group_vars/all.yml',
                    'host_vars/{{ inventory_hostname }}.yml'
                ],
                'pre_tasks': [
                    {
                        'name': 'Verify target system',
                        'debug': {
                            'msg': 'Starting system recreation on {{ inventory_hostname }}'
                        }
                    },
                    {
                        'name': 'Update apt cache',
                        'apt': {
                            'update_cache': True,
                            'cache_valid_time': 3600
                        },
                        'when': "ansible_os_family == 'Debian'"
                    }
                ],
                'roles': [
                    {'role': 'base', 'tags': ['base', 'always']},
                    {'role': 'groups', 'tags': ['groups', 'users']},
                    {'role': 'users', 'tags': ['users']},
                    {'role': 'packages', 'tags': ['packages']},
                    {'role': 'directories', 'tags': ['directories', 'filesystem']},
                    {'role': 'mounts', 'tags': ['mounts', 'filesystem']},
                    {'role': 'network', 'tags': ['network']},
                    {'role': 'firewall', 'tags': ['firewall', 'security']},
                    {'role': 'services', 'tags': ['services']},
                    {'role': 'docker', 'tags': ['docker', 'containers']},
                    {'role': 'cron', 'tags': ['cron', 'scheduled']},
                    {'role': 'configs', 'tags': ['configs', 'configuration']}
                ],
                'post_tasks': [
                    {
                        'name': 'System recreation complete',
                        'debug': {
                            'msg': 'System recreation completed successfully on {{ inventory_hostname }}'
                        }
                    }
                ]
            }
        ]

        with open(os.path.join(output_dir, 'site.yml'), 'w') as f:
            yaml.dump(playbook, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

        # Generate individual role playbooks
        role_playbooks = {
            'base.yml': ['base'],
            'users.yml': ['groups', 'users'],
            'packages.yml': ['packages'],
            'services.yml': ['services'],
            'docker.yml': ['docker'],
            'network.yml': ['network', 'firewall'],
            'filesystem.yml': ['directories', 'mounts'],
            'cron.yml': ['cron'],
            'configs.yml': ['configs']
        }

        for filename, roles in role_playbooks.items():
            pb = [{
                'name': f'{filename.replace(".yml", "").title()} Configuration',
                'hosts': 'target_servers',
                'become': True,
                'vars_files': ['group_vars/all.yml'],
                'roles': roles
            }]
            with open(os.path.join(output_dir, filename), 'w') as f:
                yaml.dump(pb, f, default_flow_style=False, sort_keys=False)

    def _get_all_packages(self) -> Dict[str, List[str]]:
        """Extract all packages from analysis"""
        packages = {
            'apt': [],
            'yum': [],
            'pip': [],
            'pip3': [],
            'npm': [],
            'snap': [],
            'gem': []
        }

        # From installed packages
        installed = self.data.get('files', {}).get('installed_packages', [])
        for pkg in installed:
            manager = pkg.get('manager', '').lower()
            name = pkg.get('name', '')
            if name:
                if manager in ['apt', 'dpkg']:
                    packages['apt'].append(name)
                elif manager in ['yum', 'rpm', 'dnf']:
                    packages['yum'].append(name)
                elif manager == 'pip':
                    packages['pip3'].append(name)
                elif manager == 'npm':
                    packages['npm'].append(name)

        # From bash history
        history = self.data.get('history', {})
        pkg_installs = history.get('package_installations', [])

        for cmd in pkg_installs:
            command = cmd.get('command', '')

            # apt/apt-get install
            match = re.search(r'(?:apt|apt-get)\s+install\s+(?:-y\s+)?(.+)', command)
            if match:
                pkgs = [p for p in match.group(1).split() if not p.startswith('-')]
                packages['apt'].extend(pkgs)

            # pip install
            match = re.search(r'pip3?\s+install\s+(.+)', command)
            if match:
                pkgs = [p for p in match.group(1).split() if not p.startswith('-')]
                packages['pip3'].extend(pkgs)

            # npm install -g
            match = re.search(r'npm\s+(?:install|i)\s+(?:-g|--global)\s+(.+)', command)
            if match:
                pkgs = [p for p in match.group(1).split() if not p.startswith('-')]
                packages['npm'].extend(pkgs)

            # snap install
            match = re.search(r'snap\s+install\s+(.+)', command)
            if match:
                pkgs = [p for p in match.group(1).split() if not p.startswith('-')]
                packages['snap'].extend(pkgs)

        # Deduplicate while preserving order
        for key in packages:
            packages[key] = list(dict.fromkeys(packages[key]))

        return packages

    def _get_all_services(self) -> Dict[str, List[Dict]]:
        """Get all services with their states"""
        services = {
            'enabled': [],
            'running': [],
            'custom_units': []
        }

        for svc in self.data.get('processes', {}).get('services', []):
            svc_name = svc.get('name', '')
            if not svc_name:
                continue

            # Skip system services
            skip_patterns = ['dbus', 'systemd-', 'getty', 'user@', 'session-', 'snap.', 'snapd']
            if any(p in svc_name for p in skip_patterns):
                continue

            svc_info = {
                'name': svc_name,
                'description': svc.get('description', '')
            }

            if svc.get('active') == 'active':
                if svc.get('status') == 'running':
                    services['running'].append(svc_info)
                services['enabled'].append(svc_info)

        return services

    def _get_users(self) -> List[Dict]:
        """Extract user information"""
        users = []
        # Get from history analyzer users
        history_users = self.data.get('history', {}).get('users_analyzed', [])

        # Get from secrets (authorized keys)
        auth_keys = self.data.get('secrets', {}).get('authorized_keys', [])
        users_with_keys = {ak.get('owner'): ak for ak in auth_keys}

        # Build user list
        seen = set()
        for username in history_users:
            if username in seen or username in ['root']:
                continue
            seen.add(username)

            user_info = {
                'name': username,
                'shell': '/bin/bash',
                'create_home': True,
                'groups': [],
                'authorized_keys': []
            }

            if username in users_with_keys:
                user_info['authorized_keys'] = users_with_keys[username].get('key_identifiers', [])

            users.append(user_info)

        return users

    def _get_docker_info(self) -> Dict[str, Any]:
        """Extract Docker container and configuration info"""
        docker = {
            'containers': [],
            'images': [],
            'networks': [],
            'volumes': [],
            'compose_files': []
        }

        processes = self.data.get('processes', {})

        # Find docker containers from running processes
        for proc in processes.get('running', []):
            cmdline = proc.get('cmdline', '')
            if 'docker' in cmdline or 'containerd' in cmdline:
                # It's a container-related process
                pass

        # Look for docker-related services
        for svc in processes.get('services', []):
            if 'docker' in svc.get('name', '').lower():
                docker['docker_service'] = svc.get('name')

        return docker

    def _get_listening_ports(self) -> List[Dict]:
        """Get listening ports for firewall configuration"""
        ports = []
        seen = set()

        for p in self.data.get('processes', {}).get('listening_ports', []):
            port = p.get('port', 0)
            if port and port not in seen and 0 < port < 65535:
                seen.add(port)
                ports.append({
                    'port': port,
                    'process': p.get('process', 'unknown'),
                    'proto': 'tcp'
                })

        return sorted(ports, key=lambda x: x['port'])

    def _generate_group_vars(self, output_dir: str) -> None:
        """Generate group variables"""
        packages = self._get_all_packages()
        services = self._get_all_services()
        users = self._get_users()
        ports = self._get_listening_ports()

        # Essential packages that should always be installed
        essential_packages = [
            'curl', 'wget', 'vim', 'git', 'htop', 'net-tools',
            'ca-certificates', 'gnupg', 'lsb-release', 'sudo',
            'apt-transport-https', 'software-properties-common'
        ]

        # Merge with detected packages
        apt_packages = list(dict.fromkeys(essential_packages + packages['apt']))

        vars_content = {
            '---': None,  # YAML document start marker
            'hostname': self.hostname,
            'timezone': 'UTC',  # Will be overridden by detected value

            # Target connection
            'target_host': '{{ lookup("env", "TARGET_HOST") | default("127.0.0.1") }}',
            'ansible_user': 'root',

            # Packages
            'apt_packages': apt_packages[:200],  # Increased limit
            'apt_packages_extra': packages['apt'][200:] if len(packages['apt']) > 200 else [],
            'pip_packages': packages['pip3'][:100],
            'npm_global_packages': packages['npm'][:50],
            'snap_packages': packages['snap'][:30],

            # Users
            'system_users': users,
            'create_deploy_user': True,
            'deploy_user': {
                'name': 'deploy',
                'groups': ['sudo', 'docker'],
                'shell': '/bin/bash'
            },

            # Services
            'services_to_enable': [s['name'] for s in services['enabled'][:50]],
            'services_to_start': [s['name'] for s in services['running'][:50]],

            # Firewall
            'firewall_enabled': True,
            'firewall_default_policy': 'deny',
            'firewall_allowed_tcp_ports': [p['port'] for p in ports if p['proto'] == 'tcp'][:30],
            'firewall_allowed_udp_ports': [],
            'firewall_allow_ssh': True,
            'ssh_port': 22,

            # Docker
            'docker_enabled': any('docker' in str(p) for p in packages['apt']),
            'docker_compose_version': '2.21.0',
            'docker_users': ['deploy'],

            # System
            'system_locale': 'en_US.UTF-8',
            'system_swappiness': 10,
            'fs_file_max': 100000,

            # Directories to create
            'create_directories': [
                {'path': '/opt/apps', 'owner': 'root', 'group': 'root', 'mode': '0755'},
                {'path': '/srv/data', 'owner': 'root', 'group': 'root', 'mode': '0755'},
            ],

            # Mount points (customize based on analysis)
            'mount_points': [],

            # Cron jobs
            'cron_jobs': [],

            # SSH configuration
            'ssh_permit_root_login': 'prohibit-password',
            'ssh_password_authentication': False,
            'ssh_pubkey_authentication': True,
        }

        # Remove the None value for YAML marker
        del vars_content['---']

        with open(os.path.join(output_dir, 'group_vars', 'all.yml'), 'w') as f:
            f.write('---\n# Group Variables - Full System Recreation\n')
            f.write(f'# Generated for: {self.hostname}\n\n')
            yaml.dump(vars_content, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

    def _generate_host_vars(self, output_dir: str) -> None:
        """Generate host-specific variables"""
        host_vars = {
            'ansible_host': '{{ target_host }}',
            'host_specific_packages': [],
            'host_specific_services': [],
        }

        with open(os.path.join(output_dir, 'host_vars', f'{self.hostname}.yml'), 'w') as f:
            f.write(f'---\n# Host Variables for: {self.hostname}\n\n')
            yaml.dump(host_vars, f, default_flow_style=False, sort_keys=False)

    def _generate_base_role(self, output_dir: str) -> None:
        """Generate base system configuration role"""
        role_dir = os.path.join(output_dir, 'roles', 'base')

        tasks = [
            {'name': 'Set hostname', 'hostname': {'name': '{{ hostname }}'}},
            {'name': 'Set timezone', 'timezone': {'name': '{{ timezone }}'}},
            {
                'name': 'Configure locale',
                'locale_gen': {
                    'name': '{{ system_locale }}',
                    'state': 'present'
                }
            },
            {
                'name': 'Set default locale',
                'copy': {
                    'content': 'LANG={{ system_locale }}\n',
                    'dest': '/etc/default/locale',
                    'mode': '0644'
                }
            },
            {
                'name': 'Configure sysctl settings',
                'sysctl': {
                    'name': '{{ item.name }}',
                    'value': '{{ item.value }}',
                    'state': 'present',
                    'reload': True
                },
                'loop': [
                    {'name': 'vm.swappiness', 'value': '{{ system_swappiness }}'},
                    {'name': 'fs.file-max', 'value': '{{ fs_file_max }}'},
                    {'name': 'net.core.somaxconn', 'value': '65535'},
                    {'name': 'net.ipv4.tcp_max_syn_backlog', 'value': '65535'},
                ]
            },
            {
                'name': 'Ensure /etc/hosts has hostname entry',
                'lineinfile': {
                    'path': '/etc/hosts',
                    'line': '127.0.1.1 {{ hostname }}',
                    'regexp': '^127\\.0\\.1\\.1',
                    'state': 'present'
                }
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Base system configuration tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'hostname': 'server',
            'timezone': 'UTC',
            'system_locale': 'en_US.UTF-8',
            'system_swappiness': 10,
            'fs_file_max': 100000
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_groups_role(self, output_dir: str) -> None:
        """Generate groups management role"""
        role_dir = os.path.join(output_dir, 'roles', 'groups')

        tasks = [
            {
                'name': 'Create system groups',
                'group': {
                    'name': '{{ item.name }}',
                    'gid': '{{ item.gid | default(omit) }}',
                    'state': 'present'
                },
                'loop': '{{ system_groups }}',
                'when': 'system_groups is defined'
            },
            {
                'name': 'Ensure common groups exist',
                'group': {
                    'name': '{{ item }}',
                    'state': 'present'
                },
                'loop': ['sudo', 'docker', 'admin', 'www-data']
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Group management tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'system_groups': []
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_users_role(self, output_dir: str) -> None:
        """Generate comprehensive users management role"""
        role_dir = os.path.join(output_dir, 'roles', 'users')

        tasks = [
            {
                'name': 'Create system users',
                'user': {
                    'name': '{{ item.name }}',
                    'uid': '{{ item.uid | default(omit) }}',
                    'group': '{{ item.group | default(item.name) }}',
                    'groups': '{{ item.groups | default([]) | join(",") }}',
                    'shell': '{{ item.shell | default("/bin/bash") }}',
                    'home': '{{ item.home | default("/home/" + item.name) }}',
                    'create_home': '{{ item.create_home | default(true) }}',
                    'password': '{{ item.password_hash | default(omit) }}',
                    'state': 'present'
                },
                'loop': '{{ system_users }}',
                'when': 'system_users is defined and system_users | length > 0'
            },
            {
                'name': 'Create deploy user',
                'user': {
                    'name': '{{ deploy_user.name }}',
                    'groups': '{{ deploy_user.groups | join(",") }}',
                    'shell': '{{ deploy_user.shell }}',
                    'create_home': True,
                    'state': 'present'
                },
                'when': 'create_deploy_user | default(false)'
            },
            {
                'name': 'Ensure .ssh directory exists for users',
                'file': {
                    'path': '/home/{{ item.name }}/.ssh',
                    'state': 'directory',
                    'owner': '{{ item.name }}',
                    'group': '{{ item.name }}',
                    'mode': '0700'
                },
                'loop': '{{ system_users }}',
                'when': 'system_users is defined'
            },
            {
                'name': 'Add authorized keys for users',
                'authorized_key': {
                    'user': '{{ item.0.name }}',
                    'key': '{{ item.1 }}',
                    'state': 'present'
                },
                'loop': "{{ system_users | subelements('authorized_keys', skip_missing=True) }}",
                'when': 'system_users is defined'
            },
            {
                'name': 'Configure sudo access for users',
                'copy': {
                    'content': '{{ item.name }} ALL=(ALL) NOPASSWD:ALL\n',
                    'dest': '/etc/sudoers.d/{{ item.name }}',
                    'mode': '0440',
                    'validate': 'visudo -cf %s'
                },
                'loop': '{{ system_users | selectattr("sudo", "defined") | selectattr("sudo") | list }}',
                'when': 'system_users is defined'
            },
            {
                'name': 'Copy user shell configuration files',
                'copy': {
                    'src': 'users/{{ item.0.name }}/{{ item.1 }}',
                    'dest': '/home/{{ item.0.name }}/{{ item.1 }}',
                    'owner': '{{ item.0.name }}',
                    'group': '{{ item.0.name }}',
                    'mode': '0644'
                },
                'loop': "{{ system_users | subelements('shell_configs', skip_missing=True) }}",
                'when': 'system_users is defined',
                'ignore_errors': True
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# User management tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'system_users': [],
            'create_deploy_user': True,
            'deploy_user': {
                'name': 'deploy',
                'groups': ['sudo', 'docker'],
                'shell': '/bin/bash'
            }
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_packages_role(self, output_dir: str) -> None:
        """Generate comprehensive packages installation role"""
        role_dir = os.path.join(output_dir, 'roles', 'packages')

        tasks = [
            {
                'name': 'Update apt cache',
                'apt': {
                    'update_cache': True,
                    'cache_valid_time': 3600
                },
                'when': "ansible_os_family == 'Debian'"
            },
            {
                'name': 'Install apt packages',
                'apt': {
                    'name': '{{ apt_packages }}',
                    'state': 'present',
                    'install_recommends': False
                },
                'when': "ansible_os_family == 'Debian' and apt_packages | length > 0",
                'register': 'apt_result',
                'retries': 3,
                'delay': 5,
                'until': 'apt_result is succeeded'
            },
            {
                'name': 'Install extra apt packages',
                'apt': {
                    'name': '{{ apt_packages_extra }}',
                    'state': 'present',
                    'install_recommends': False
                },
                'when': "ansible_os_family == 'Debian' and apt_packages_extra is defined and apt_packages_extra | length > 0",
                'ignore_errors': True
            },
            {
                'name': 'Install YUM packages',
                'yum': {
                    'name': '{{ yum_packages }}',
                    'state': 'present'
                },
                'when': "ansible_os_family == 'RedHat' and yum_packages is defined and yum_packages | length > 0"
            },
            {
                'name': 'Install pip3',
                'apt': {
                    'name': ['python3-pip', 'python3-venv', 'python3-dev'],
                    'state': 'present'
                },
                'when': "ansible_os_family == 'Debian' and pip_packages | length > 0"
            },
            {
                'name': 'Install pip packages',
                'pip': {
                    'name': '{{ pip_packages }}',
                    'state': 'present',
                    'executable': 'pip3'
                },
                'when': 'pip_packages | length > 0',
                'ignore_errors': True
            },
            {
                'name': 'Install Node.js and npm',
                'apt': {
                    'name': ['nodejs', 'npm'],
                    'state': 'present'
                },
                'when': "ansible_os_family == 'Debian' and npm_global_packages | length > 0"
            },
            {
                'name': 'Install global npm packages',
                'npm': {
                    'name': '{{ item }}',
                    'global': True,
                    'state': 'present'
                },
                'loop': '{{ npm_global_packages }}',
                'when': 'npm_global_packages | length > 0',
                'ignore_errors': True
            },
            {
                'name': 'Install snap packages',
                'snap': {
                    'name': '{{ item }}',
                    'state': 'present'
                },
                'loop': '{{ snap_packages }}',
                'when': 'snap_packages is defined and snap_packages | length > 0',
                'ignore_errors': True
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Package installation tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'apt_packages': [],
            'apt_packages_extra': [],
            'yum_packages': [],
            'pip_packages': [],
            'npm_global_packages': [],
            'snap_packages': []
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_services_role(self, output_dir: str) -> None:
        """Generate services management role"""
        role_dir = os.path.join(output_dir, 'roles', 'services')

        tasks = [
            {
                'name': 'Reload systemd daemon',
                'systemd': {
                    'daemon_reload': True
                }
            },
            {
                'name': 'Copy custom service unit files',
                'copy': {
                    'src': '{{ item }}',
                    'dest': '/etc/systemd/system/',
                    'mode': '0644'
                },
                'loop': "{{ lookup('fileglob', 'files/*.service', wantlist=True) }}",
                'notify': 'reload systemd',
                'ignore_errors': True
            },
            {
                'name': 'Enable services',
                'systemd': {
                    'name': '{{ item }}',
                    'enabled': True
                },
                'loop': '{{ services_to_enable }}',
                'when': 'services_to_enable | length > 0',
                'ignore_errors': True
            },
            {
                'name': 'Start services',
                'systemd': {
                    'name': '{{ item }}',
                    'state': 'started'
                },
                'loop': '{{ services_to_start }}',
                'when': 'services_to_start | length > 0',
                'ignore_errors': True
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Service management tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        handlers = [
            {
                'name': 'reload systemd',
                'systemd': {
                    'daemon_reload': True
                }
            },
            {
                'name': 'restart service',
                'systemd': {
                    'name': '{{ item }}',
                    'state': 'restarted'
                },
                'loop': '{{ services_to_start }}'
            }
        ]

        with open(os.path.join(role_dir, 'handlers', 'main.yml'), 'w') as f:
            yaml.dump(handlers, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'services_to_enable': [],
            'services_to_start': []
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_firewall_role(self, output_dir: str) -> None:
        """Generate firewall configuration role"""
        role_dir = os.path.join(output_dir, 'roles', 'firewall')

        tasks = [
            {
                'name': 'Install UFW',
                'apt': {
                    'name': 'ufw',
                    'state': 'present'
                },
                'when': "ansible_os_family == 'Debian' and firewall_enabled"
            },
            {
                'name': 'Reset UFW to defaults',
                'ufw': {
                    'state': 'reset'
                },
                'when': 'firewall_enabled and firewall_reset | default(false)'
            },
            {
                'name': 'Set UFW default policy - deny incoming',
                'ufw': {
                    'direction': 'incoming',
                    'policy': '{{ firewall_default_policy }}'
                },
                'when': 'firewall_enabled'
            },
            {
                'name': 'Set UFW default policy - allow outgoing',
                'ufw': {
                    'direction': 'outgoing',
                    'policy': 'allow'
                },
                'when': 'firewall_enabled'
            },
            {
                'name': 'Allow SSH through firewall',
                'ufw': {
                    'rule': 'allow',
                    'port': '{{ ssh_port }}',
                    'proto': 'tcp',
                    'comment': 'SSH access'
                },
                'when': 'firewall_enabled and firewall_allow_ssh'
            },
            {
                'name': 'Allow TCP ports through firewall',
                'ufw': {
                    'rule': 'allow',
                    'port': '{{ item }}',
                    'proto': 'tcp',
                    'comment': 'Allowed TCP port'
                },
                'loop': '{{ firewall_allowed_tcp_ports }}',
                'when': 'firewall_enabled and firewall_allowed_tcp_ports | length > 0'
            },
            {
                'name': 'Allow UDP ports through firewall',
                'ufw': {
                    'rule': 'allow',
                    'port': '{{ item }}',
                    'proto': 'udp',
                    'comment': 'Allowed UDP port'
                },
                'loop': '{{ firewall_allowed_udp_ports }}',
                'when': 'firewall_enabled and firewall_allowed_udp_ports | length > 0'
            },
            {
                'name': 'Allow specific IP ranges',
                'ufw': {
                    'rule': 'allow',
                    'from_ip': '{{ item.from }}',
                    'to_port': '{{ item.port | default(omit) }}',
                    'proto': '{{ item.proto | default("any") }}',
                    'comment': '{{ item.comment | default("Allowed IP range") }}'
                },
                'loop': '{{ firewall_allowed_ranges | default([]) }}'
            },
            {
                'name': 'Enable UFW',
                'ufw': {
                    'state': 'enabled'
                },
                'when': 'firewall_enabled'
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Firewall configuration tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'firewall_enabled': True,
            'firewall_default_policy': 'deny',
            'firewall_allow_ssh': True,
            'ssh_port': 22,
            'firewall_allowed_tcp_ports': [22, 80, 443],
            'firewall_allowed_udp_ports': [],
            'firewall_allowed_ranges': []
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_mounts_role(self, output_dir: str) -> None:
        """Generate filesystem mounts role"""
        role_dir = os.path.join(output_dir, 'roles', 'mounts')

        tasks = [
            {
                'name': 'Install NFS client utilities',
                'apt': {
                    'name': 'nfs-common',
                    'state': 'present'
                },
                'when': "ansible_os_family == 'Debian' and mount_points | selectattr('fstype', 'equalto', 'nfs') | list | length > 0"
            },
            {
                'name': 'Install CIFS utilities',
                'apt': {
                    'name': 'cifs-utils',
                    'state': 'present'
                },
                'when': "ansible_os_family == 'Debian' and mount_points | selectattr('fstype', 'equalto', 'cifs') | list | length > 0"
            },
            {
                'name': 'Create mount point directories',
                'file': {
                    'path': '{{ item.path }}',
                    'state': 'directory',
                    'owner': '{{ item.owner | default("root") }}',
                    'group': '{{ item.group | default("root") }}',
                    'mode': '{{ item.mode | default("0755") }}'
                },
                'loop': '{{ mount_points }}'
            },
            {
                'name': 'Configure mount points in fstab',
                'mount': {
                    'path': '{{ item.path }}',
                    'src': '{{ item.src }}',
                    'fstype': '{{ item.fstype }}',
                    'opts': '{{ item.opts | default("defaults") }}',
                    'state': '{{ item.state | default("mounted") }}',
                    'dump': '{{ item.dump | default(0) }}',
                    'passno': '{{ item.passno | default(0) }}'
                },
                'loop': '{{ mount_points }}',
                'when': 'mount_points | length > 0'
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Mount configuration tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'mount_points': [
                # Example mount configurations
                # {'path': '/mnt/data', 'src': '/dev/sdb1', 'fstype': 'ext4', 'opts': 'defaults'},
                # {'path': '/mnt/nfs', 'src': 'nfs-server:/export', 'fstype': 'nfs', 'opts': 'rw,sync'},
            ]
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            f.write('---\n# Mount point defaults\n# Add your mount configurations here\n\n')
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_directories_role(self, output_dir: str) -> None:
        """Generate directory structure role"""
        role_dir = os.path.join(output_dir, 'roles', 'directories')

        tasks = [
            {
                'name': 'Create required directories',
                'file': {
                    'path': '{{ item.path }}',
                    'state': 'directory',
                    'owner': '{{ item.owner | default("root") }}',
                    'group': '{{ item.group | default("root") }}',
                    'mode': '{{ item.mode | default("0755") }}',
                    'recurse': '{{ item.recurse | default(false) }}'
                },
                'loop': '{{ create_directories }}'
            },
            {
                'name': 'Create application directories',
                'file': {
                    'path': '{{ item }}',
                    'state': 'directory',
                    'owner': 'root',
                    'group': 'root',
                    'mode': '0755'
                },
                'loop':
                    - '/opt/apps'
                    - '/opt/scripts'
                    - '/srv/data'
                    - '/var/log/apps'
            },
            {
                'name': 'Create user-specific directories',
                'file': {
                    'path': '/home/{{ item.0.name }}/{{ item.1 }}',
                    'state': 'directory',
                    'owner': '{{ item.0.name }}',
                    'group': '{{ item.0.name }}',
                    'mode': '0755'
                },
                'loop': "{{ system_users | subelements('directories', skip_missing=True) }}",
                'when': 'system_users is defined'
            }
        ]

        # Fix YAML list in tasks
        tasks[1]['loop'] = ['/opt/apps', '/opt/scripts', '/srv/data', '/var/log/apps']

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Directory structure tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'create_directories': [
                {'path': '/opt/apps', 'owner': 'root', 'group': 'root', 'mode': '0755'},
                {'path': '/srv/data', 'owner': 'root', 'group': 'root', 'mode': '0755'},
            ]
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_docker_role(self, output_dir: str) -> None:
        """Generate Docker installation and configuration role"""
        role_dir = os.path.join(output_dir, 'roles', 'docker')

        tasks = [
            {
                'name': 'Install Docker prerequisites',
                'apt': {
                    'name': [
                        'apt-transport-https',
                        'ca-certificates',
                        'curl',
                        'gnupg',
                        'lsb-release'
                    ],
                    'state': 'present'
                },
                'when': "docker_enabled and ansible_os_family == 'Debian'"
            },
            {
                'name': 'Add Docker GPG key',
                'apt_key': {
                    'url': 'https://download.docker.com/linux/{{ ansible_distribution | lower }}/gpg',
                    'state': 'present'
                },
                'when': "docker_enabled and ansible_os_family == 'Debian'"
            },
            {
                'name': 'Add Docker repository',
                'apt_repository': {
                    'repo': 'deb [arch=amd64] https://download.docker.com/linux/{{ ansible_distribution | lower }} {{ ansible_distribution_release }} stable',
                    'state': 'present',
                    'filename': 'docker'
                },
                'when': "docker_enabled and ansible_os_family == 'Debian'"
            },
            {
                'name': 'Install Docker packages',
                'apt': {
                    'name': [
                        'docker-ce',
                        'docker-ce-cli',
                        'containerd.io',
                        'docker-buildx-plugin',
                        'docker-compose-plugin'
                    ],
                    'state': 'present',
                    'update_cache': True
                },
                'when': "docker_enabled and ansible_os_family == 'Debian'"
            },
            {
                'name': 'Ensure Docker group exists',
                'group': {
                    'name': 'docker',
                    'state': 'present'
                },
                'when': 'docker_enabled'
            },
            {
                'name': 'Add users to Docker group',
                'user': {
                    'name': '{{ item }}',
                    'groups': 'docker',
                    'append': True
                },
                'loop': '{{ docker_users }}',
                'when': 'docker_enabled and docker_users | length > 0'
            },
            {
                'name': 'Create Docker configuration directory',
                'file': {
                    'path': '/etc/docker',
                    'state': 'directory',
                    'mode': '0755'
                },
                'when': 'docker_enabled'
            },
            {
                'name': 'Configure Docker daemon',
                'template': {
                    'src': 'daemon.json.j2',
                    'dest': '/etc/docker/daemon.json',
                    'mode': '0644'
                },
                'notify': 'restart docker',
                'when': 'docker_enabled and docker_daemon_config is defined'
            },
            {
                'name': 'Enable and start Docker service',
                'systemd': {
                    'name': 'docker',
                    'enabled': True,
                    'state': 'started'
                },
                'when': 'docker_enabled'
            },
            {
                'name': 'Create Docker networks',
                'docker_network': {
                    'name': '{{ item.name }}',
                    'driver': '{{ item.driver | default("bridge") }}',
                    'state': 'present'
                },
                'loop': '{{ docker_networks }}',
                'when': 'docker_enabled and docker_networks is defined'
            },
            {
                'name': 'Create Docker volumes',
                'docker_volume': {
                    'name': '{{ item.name }}',
                    'state': 'present'
                },
                'loop': '{{ docker_volumes }}',
                'when': 'docker_enabled and docker_volumes is defined'
            },
            {
                'name': 'Pull Docker images',
                'docker_image': {
                    'name': '{{ item }}',
                    'source': 'pull'
                },
                'loop': '{{ docker_images }}',
                'when': 'docker_enabled and docker_images is defined',
                'ignore_errors': True
            },
            {
                'name': 'Copy Docker compose files',
                'copy': {
                    'src': '{{ item }}',
                    'dest': '/opt/docker-compose/',
                    'mode': '0644'
                },
                'loop': "{{ lookup('fileglob', 'files/compose/*.yml', wantlist=True) }}",
                'when': 'docker_enabled',
                'ignore_errors': True
            },
            {
                'name': 'Start Docker containers',
                'docker_container': {
                    'name': '{{ item.name }}',
                    'image': '{{ item.image }}',
                    'state': 'started',
                    'restart_policy': '{{ item.restart_policy | default("unless-stopped") }}',
                    'ports': '{{ item.ports | default([]) }}',
                    'volumes': '{{ item.volumes | default([]) }}',
                    'env': '{{ item.env | default({}) }}',
                    'networks': '{{ item.networks | default([]) }}'
                },
                'loop': '{{ docker_containers }}',
                'when': 'docker_enabled and docker_containers is defined'
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Docker installation and configuration tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        handlers = [
            {
                'name': 'restart docker',
                'systemd': {
                    'name': 'docker',
                    'state': 'restarted'
                }
            }
        ]

        with open(os.path.join(role_dir, 'handlers', 'main.yml'), 'w') as f:
            yaml.dump(handlers, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'docker_enabled': False,
            'docker_users': ['deploy'],
            'docker_networks': [],
            'docker_volumes': [],
            'docker_images': [],
            'docker_containers': [],
            'docker_daemon_config': {
                'log-driver': 'json-file',
                'log-opts': {
                    'max-size': '10m',
                    'max-file': '3'
                },
                'storage-driver': 'overlay2'
            }
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

        # Create daemon.json template
        daemon_template = '''{{ docker_daemon_config | to_nice_json }}
'''
        with open(os.path.join(role_dir, 'templates', 'daemon.json.j2'), 'w') as f:
            f.write(daemon_template)

    def _generate_cron_role(self, output_dir: str) -> None:
        """Generate cron jobs role"""
        role_dir = os.path.join(output_dir, 'roles', 'cron')

        tasks = [
            {
                'name': 'Install cron package',
                'apt': {
                    'name': 'cron',
                    'state': 'present'
                },
                'when': "ansible_os_family == 'Debian'"
            },
            {
                'name': 'Enable cron service',
                'systemd': {
                    'name': 'cron',
                    'enabled': True,
                    'state': 'started'
                }
            },
            {
                'name': 'Create cron jobs',
                'cron': {
                    'name': '{{ item.name }}',
                    'user': '{{ item.user | default("root") }}',
                    'minute': '{{ item.minute | default("*") }}',
                    'hour': '{{ item.hour | default("*") }}',
                    'day': '{{ item.day | default("*") }}',
                    'month': '{{ item.month | default("*") }}',
                    'weekday': '{{ item.weekday | default("*") }}',
                    'job': '{{ item.job }}',
                    'state': 'present'
                },
                'loop': '{{ cron_jobs }}',
                'when': 'cron_jobs | length > 0'
            },
            {
                'name': 'Copy cron.d files',
                'copy': {
                    'src': '{{ item }}',
                    'dest': '/etc/cron.d/',
                    'mode': '0644',
                    'owner': 'root',
                    'group': 'root'
                },
                'loop': "{{ lookup('fileglob', 'files/cron.d/*', wantlist=True) }}",
                'ignore_errors': True
            },
            {
                'name': 'Copy daily cron scripts',
                'copy': {
                    'src': '{{ item }}',
                    'dest': '/etc/cron.daily/',
                    'mode': '0755'
                },
                'loop': "{{ lookup('fileglob', 'files/cron.daily/*', wantlist=True) }}",
                'ignore_errors': True
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Cron job configuration tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'cron_jobs': [
                # Example cron job configurations
                # {'name': 'Daily backup', 'hour': '2', 'minute': '0', 'job': '/opt/scripts/backup.sh'},
                # {'name': 'Log cleanup', 'hour': '3', 'minute': '0', 'weekday': '0', 'job': '/opt/scripts/cleanup.sh'},
            ]
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            f.write('---\n# Cron job defaults\n# Add your cron job configurations here\n\n')
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_network_role(self, output_dir: str) -> None:
        """Generate network configuration role"""
        role_dir = os.path.join(output_dir, 'roles', 'network')

        tasks = [
            {
                'name': 'Configure /etc/hosts entries',
                'lineinfile': {
                    'path': '/etc/hosts',
                    'line': '{{ item.ip }} {{ item.hostname }} {{ item.aliases | default("") }}',
                    'state': 'present'
                },
                'loop': '{{ hosts_entries }}',
                'when': 'hosts_entries is defined and hosts_entries | length > 0'
            },
            {
                'name': 'Configure DNS resolvers',
                'template': {
                    'src': 'resolv.conf.j2',
                    'dest': '/etc/resolv.conf',
                    'mode': '0644'
                },
                'when': 'dns_servers is defined and manage_resolv_conf | default(false)'
            },
            {
                'name': 'Copy netplan configuration',
                'copy': {
                    'src': '{{ item }}',
                    'dest': '/etc/netplan/',
                    'mode': '0644'
                },
                'loop': "{{ lookup('fileglob', 'files/netplan/*.yaml', wantlist=True) }}",
                'notify': 'apply netplan',
                'when': "ansible_distribution == 'Ubuntu'",
                'ignore_errors': True
            },
            {
                'name': 'Configure static routes',
                'command': 'ip route add {{ item.dest }} via {{ item.gateway }} dev {{ item.interface | default("eth0") }}',
                'loop': '{{ static_routes }}',
                'when': 'static_routes is defined and static_routes | length > 0',
                'ignore_errors': True
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# Network configuration tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        handlers = [
            {
                'name': 'apply netplan',
                'command': 'netplan apply'
            }
        ]

        with open(os.path.join(role_dir, 'handlers', 'main.yml'), 'w') as f:
            yaml.dump(handlers, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'hosts_entries': [],
            'dns_servers': ['8.8.8.8', '8.8.4.4'],
            'dns_search_domains': [],
            'static_routes': [],
            'manage_resolv_conf': False
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

        # Create resolv.conf template
        resolv_template = '''# Generated by Ansible
{% for server in dns_servers %}
nameserver {{ server }}
{% endfor %}
{% if dns_search_domains %}
search {{ dns_search_domains | join(' ') }}
{% endif %}
'''
        with open(os.path.join(role_dir, 'templates', 'resolv.conf.j2'), 'w') as f:
            f.write(resolv_template)

    def _generate_configs_role(self, output_dir: str) -> None:
        """Generate system configuration files role"""
        role_dir = os.path.join(output_dir, 'roles', 'configs')

        tasks = [
            {
                'name': 'Configure SSH daemon',
                'template': {
                    'src': 'sshd_config.j2',
                    'dest': '/etc/ssh/sshd_config',
                    'mode': '0644',
                    'validate': 'sshd -t -f %s'
                },
                'notify': 'restart sshd',
                'when': 'configure_sshd | default(true)'
            },
            {
                'name': 'Configure sudoers',
                'template': {
                    'src': 'sudoers.j2',
                    'dest': '/etc/sudoers',
                    'mode': '0440',
                    'validate': 'visudo -cf %s'
                },
                'when': 'configure_sudoers | default(false)'
            },
            {
                'name': 'Copy sudoers.d files',
                'copy': {
                    'src': '{{ item }}',
                    'dest': '/etc/sudoers.d/',
                    'mode': '0440',
                    'validate': 'visudo -cf %s'
                },
                'loop': "{{ lookup('fileglob', 'files/sudoers.d/*', wantlist=True) }}",
                'ignore_errors': True
            },
            {
                'name': 'Configure system limits',
                'copy': {
                    'src': 'limits.conf',
                    'dest': '/etc/security/limits.conf',
                    'mode': '0644'
                },
                'when': "lookup('fileglob', 'files/limits.conf') | length > 0",
                'ignore_errors': True
            },
            {
                'name': 'Configure sysctl parameters',
                'sysctl': {
                    'name': '{{ item.name }}',
                    'value': '{{ item.value }}',
                    'state': 'present',
                    'reload': True
                },
                'loop': '{{ sysctl_params }}',
                'when': 'sysctl_params is defined and sysctl_params | length > 0'
            },
            {
                'name': 'Copy environment files',
                'copy': {
                    'src': '{{ item }}',
                    'dest': '/etc/',
                    'mode': '0644'
                },
                'loop': "{{ lookup('fileglob', 'files/environment', wantlist=True) }}",
                'ignore_errors': True
            },
            {
                'name': 'Copy profile.d scripts',
                'copy': {
                    'src': '{{ item }}',
                    'dest': '/etc/profile.d/',
                    'mode': '0644'
                },
                'loop': "{{ lookup('fileglob', 'files/profile.d/*', wantlist=True) }}",
                'ignore_errors': True
            },
            {
                'name': 'Copy service configuration files',
                'copy': {
                    'src': '{{ item.src }}',
                    'dest': '{{ item.dest }}',
                    'mode': '{{ item.mode | default("0644") }}',
                    'owner': '{{ item.owner | default("root") }}',
                    'group': '{{ item.group | default("root") }}'
                },
                'loop': '{{ config_files }}',
                'when': 'config_files is defined and config_files | length > 0',
                'notify': '{{ item.notify | default(omit) }}'
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            f.write('---\n# System configuration tasks\n\n')
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        handlers = [
            {
                'name': 'restart sshd',
                'systemd': {
                    'name': 'sshd',
                    'state': 'restarted'
                }
            },
            {
                'name': 'restart nginx',
                'systemd': {
                    'name': 'nginx',
                    'state': 'restarted'
                }
            },
            {
                'name': 'restart apache',
                'systemd': {
                    'name': 'apache2',
                    'state': 'restarted'
                }
            }
        ]

        with open(os.path.join(role_dir, 'handlers', 'main.yml'), 'w') as f:
            yaml.dump(handlers, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'configure_sshd': True,
            'ssh_permit_root_login': 'prohibit-password',
            'ssh_password_authentication': False,
            'ssh_pubkey_authentication': True,
            'ssh_port': 22,
            'sysctl_params': [],
            'config_files': []
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

        # Create sshd_config template
        sshd_template = '''# SSH Server Configuration - Generated by Ansible
Port {{ ssh_port }}
Protocol 2

HostKey /etc/ssh/ssh_host_rsa_key
HostKey /etc/ssh/ssh_host_ecdsa_key
HostKey /etc/ssh/ssh_host_ed25519_key

# Logging
SyslogFacility AUTH
LogLevel INFO

# Authentication
LoginGraceTime 2m
PermitRootLogin {{ ssh_permit_root_login }}
StrictModes yes
MaxAuthTries 6
MaxSessions 10

PubkeyAuthentication {{ 'yes' if ssh_pubkey_authentication else 'no' }}
AuthorizedKeysFile .ssh/authorized_keys

PasswordAuthentication {{ 'yes' if ssh_password_authentication else 'no' }}
PermitEmptyPasswords no

ChallengeResponseAuthentication no
UsePAM yes

# Forwarding
AllowAgentForwarding yes
AllowTcpForwarding yes
X11Forwarding no

PrintMotd no
PrintLastLog yes
TCPKeepAlive yes

AcceptEnv LANG LC_*

Subsystem sftp /usr/lib/openssh/sftp-server
'''
        with open(os.path.join(role_dir, 'templates', 'sshd_config.j2'), 'w') as f:
            f.write(sshd_template)

    def _generate_helper_scripts(self, output_dir: str) -> None:
        """Generate helper scripts for running Ansible"""

        # Deploy script
        deploy_script = '''#!/bin/bash
# Deploy script for Ansible playbook execution
# Usage: ./deploy.sh [target_host] [playbook] [extra_args]

set -e

TARGET_HOST="${1:-127.0.0.1}"
PLAYBOOK="${2:-site.yml}"
shift 2 2>/dev/null || true

echo "=== Ansible Deployment Script ==="
echo "Target: $TARGET_HOST"
echo "Playbook: $PLAYBOOK"
echo ""

# Check if ansible is installed
if ! command -v ansible-playbook &> /dev/null; then
    echo "Error: ansible-playbook not found. Install ansible first."
    exit 1
fi

# Set target host
export TARGET_HOST="$TARGET_HOST"

# Run ansible playbook
ansible-playbook -i inventory "$PLAYBOOK" \\
    -e "target_host=$TARGET_HOST" \\
    "$@"

echo ""
echo "=== Deployment Complete ==="
'''

        with open(os.path.join(output_dir, 'deploy.sh'), 'w') as f:
            f.write(deploy_script)
        os.chmod(os.path.join(output_dir, 'deploy.sh'), 0o755)

        # Dry-run script
        dryrun_script = '''#!/bin/bash
# Dry-run script to test Ansible playbook without making changes
# Usage: ./dryrun.sh [target_host] [playbook]

set -e

TARGET_HOST="${1:-127.0.0.1}"
PLAYBOOK="${2:-site.yml}"

echo "=== Ansible Dry Run (Check Mode) ==="
echo "Target: $TARGET_HOST"
echo "Playbook: $PLAYBOOK"
echo ""

ansible-playbook -i inventory "$PLAYBOOK" \\
    -e "target_host=$TARGET_HOST" \\
    --check --diff

echo ""
echo "=== Dry Run Complete ==="
'''

        with open(os.path.join(output_dir, 'dryrun.sh'), 'w') as f:
            f.write(dryrun_script)
        os.chmod(os.path.join(output_dir, 'dryrun.sh'), 0o755)

        # Syntax check script
        syntax_script = '''#!/bin/bash
# Syntax check script
# Usage: ./check-syntax.sh

echo "=== Ansible Syntax Check ==="
ansible-playbook -i inventory site.yml --syntax-check

echo ""
echo "Checking individual playbooks..."
for pb in *.yml; do
    [ "$pb" = "*.yml" ] && continue
    echo "  Checking: $pb"
    ansible-playbook -i inventory "$pb" --syntax-check > /dev/null 2>&1 && echo "    OK" || echo "    FAILED"
done

echo ""
echo "=== Syntax Check Complete ==="
'''

        with open(os.path.join(output_dir, 'check-syntax.sh'), 'w') as f:
            f.write(syntax_script)
        os.chmod(os.path.join(output_dir, 'check-syntax.sh'), 0o755)

        # README for ansible directory
        readme = f'''# Ansible System Recreation

Generated for: {self.hostname}

## Quick Start

1. **Review and customize variables:**
   ```bash
   vim group_vars/all.yml
   ```

2. **Check syntax:**
   ```bash
   ./check-syntax.sh
   ```

3. **Dry run (no changes):**
   ```bash
   ./dryrun.sh <target_host>
   ```

4. **Deploy:**
   ```bash
   ./deploy.sh <target_host>
   ```

## Directory Structure

```
.
 site.yml              # Main playbook (runs all roles)
 inventory             # Host inventory
 ansible.cfg           # Ansible configuration
 group_vars/
    all.yml          # Global variables - CUSTOMIZE THIS
 host_vars/
    {self.hostname}.yml  # Host-specific variables
 roles/
    base/            # Base system configuration
    users/           # User account management
    groups/          # Group management
    packages/        # Package installation
    services/        # Service management
    firewall/        # UFW firewall configuration
    mounts/          # Filesystem mounts
    directories/     # Directory structure
    docker/          # Docker installation & containers
    cron/            # Cron job configuration
    network/         # Network configuration
    configs/         # System configuration files
 files/               # Static files to copy
 templates/           # Jinja2 templates
```

## Running Specific Roles

Use tags to run specific roles:

```bash
# Only users and groups
ansible-playbook -i inventory site.yml --tags "users"

# Only packages
ansible-playbook -i inventory site.yml --tags "packages"

# Only Docker
ansible-playbook -i inventory site.yml --tags "docker"

# Only firewall
ansible-playbook -i inventory site.yml --tags "firewall"
```

## Individual Playbooks

Run individual playbooks for specific tasks:

```bash
ansible-playbook -i inventory users.yml
ansible-playbook -i inventory packages.yml
ansible-playbook -i inventory docker.yml
ansible-playbook -i inventory network.yml
```

## Customization

### Adding Users

Edit `group_vars/all.yml`:

```yaml
system_users:
  - name: john
    uid: 1001
    groups: ['sudo', 'docker']
    shell: /bin/bash
    authorized_keys:
      - "ssh-rsa AAAA... john@example.com"
```

### Adding Packages

Edit `group_vars/all.yml`:

```yaml
apt_packages:
  - nginx
  - postgresql
  - redis-server

pip_packages:
  - flask
  - gunicorn
```

### Configuring Docker Containers

Edit `group_vars/all.yml`:

```yaml
docker_enabled: true
docker_containers:
  - name: nginx
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - /var/www:/usr/share/nginx/html:ro
```

### Adding Mount Points

Edit `group_vars/all.yml`:

```yaml
mount_points:
  - path: /mnt/data
    src: /dev/sdb1
    fstype: ext4
    opts: defaults
```

### Adding Cron Jobs

Edit `group_vars/all.yml`:

```yaml
cron_jobs:
  - name: Daily backup
    hour: "2"
    minute: "0"
    job: /opt/scripts/backup.sh
```

## Security Notes

1. Review all variables before deployment
2. Change default passwords
3. Update SSH authorized keys
4. Review firewall rules
5. Test in a staging environment first

## Troubleshooting

**Check connectivity:**
```bash
ansible -i inventory all -m ping
```

**Verbose output:**
```bash
ansible-playbook -i inventory site.yml -vvv
```

**Debug variables:**
```bash
ansible -i inventory all -m debug -a "var=hostvars"
```
'''

        with open(os.path.join(output_dir, 'README.md'), 'w') as f:
            f.write(readme)
