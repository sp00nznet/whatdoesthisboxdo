"""
Azure Terraform Generator
Generates Terraform configurations for Azure Virtual Machines
"""

import json
import logging
import os
from typing import Dict, List, Any

logger = logging.getLogger(__name__)


class AzureGenerator:
    """Generates Terraform configurations for Microsoft Azure"""

    # VM size mapping based on CPU/memory
    VM_SIZES = [
        {'vcpus': 1, 'memory_gb': 1, 'size': 'Standard_B1s'},
        {'vcpus': 1, 'memory_gb': 2, 'size': 'Standard_B1ms'},
        {'vcpus': 2, 'memory_gb': 4, 'size': 'Standard_B2s'},
        {'vcpus': 2, 'memory_gb': 8, 'size': 'Standard_B2ms'},
        {'vcpus': 4, 'memory_gb': 16, 'size': 'Standard_B4ms'},
        {'vcpus': 8, 'memory_gb': 32, 'size': 'Standard_B8ms'},
        {'vcpus': 2, 'memory_gb': 8, 'size': 'Standard_D2s_v5'},
        {'vcpus': 4, 'memory_gb': 16, 'size': 'Standard_D4s_v5'},
        {'vcpus': 8, 'memory_gb': 32, 'size': 'Standard_D8s_v5'},
        {'vcpus': 16, 'memory_gb': 64, 'size': 'Standard_D16s_v5'},
        {'vcpus': 32, 'memory_gb': 128, 'size': 'Standard_D32s_v5'},
        {'vcpus': 4, 'memory_gb': 32, 'size': 'Standard_E4s_v5'},
        {'vcpus': 8, 'memory_gb': 64, 'size': 'Standard_E8s_v5'},
    ]

    def __init__(self, analysis_data: Dict[str, Any]):
        self.data = analysis_data
        self.hostname = analysis_data.get('hostname', 'server')

    def generate(self, output_dir: str) -> str:
        """Generate all Azure Terraform files"""
        os.makedirs(output_dir, exist_ok=True)

        self._generate_provider(output_dir)
        self._generate_variables(output_dir)
        self._generate_main(output_dir)
        self._generate_outputs(output_dir)
        self._generate_cloud_init(output_dir)
        self._generate_tfvars_example(output_dir)

        logger.info(f"Azure Terraform configuration generated in: {output_dir}")
        return output_dir

    def get_recommended_vm_size(self) -> str:
        """Determine the best Azure VM size based on system specs"""
        resources = self.data.get('processes', {}).get('resource_usage', {})
        cpu = resources.get('cpu', {})
        memory = resources.get('memory', {})

        vcpus = cpu.get('count', 2)
        memory_bytes = memory.get('total', 4 * 1024 * 1024 * 1024)
        memory_gb = memory_bytes / (1024 ** 3)

        best_match = 'Standard_B2s'  # Default
        for vm in self.VM_SIZES:
            if vm['vcpus'] >= vcpus and vm['memory_gb'] >= memory_gb:
                best_match = vm['size']
                break

        return best_match

    def get_disk_size(self) -> int:
        """Get required disk size in GB"""
        resources = self.data.get('processes', {}).get('resource_usage', {})
        disk = resources.get('disk', {})

        total_bytes = 0
        for mount, usage in disk.items():
            if mount == '/' or mount.startswith('/home'):
                total_bytes += usage.get('used', 0)

        disk_gb = max(30, int((total_bytes / (1024 ** 3)) * 1.5))  # Azure min is 30GB
        return disk_gb

    def _get_nsg_rules(self) -> List[Dict]:
        """Generate NSG rules based on listening ports"""
        rules = []
        priority = 100
        listening = self.data.get('processes', {}).get('listening_ports', [])

        # Always allow SSH
        rules.append({
            'name': 'AllowSSH',
            'priority': priority,
            'port': '22',
            'protocol': 'Tcp',
            'description': 'Allow SSH access'
        })
        priority += 10

        # Add rules for detected ports
        for port_info in listening:
            port = port_info.get('port', 0)
            process = port_info.get('process', 'unknown')

            if port in [22]:
                continue
            if port > 0 and port < 65536:
                # Sanitize name
                rule_name = f"Allow_{process}_{port}".replace('-', '_').replace('.', '_')[:80]
                rules.append({
                    'name': rule_name,
                    'priority': priority,
                    'port': str(port),
                    'protocol': 'Tcp',
                    'description': f'{process} on port {port}'
                })
                priority += 10

            if priority > 4000:  # Azure limit
                break

        return rules[:30]  # Limit rules

    def _generate_provider(self, output_dir: str) -> None:
        """Generate Azure provider configuration"""
        content = '''# Azure Provider Configuration
# Generated by System Analyzer

terraform {
  required_version = ">= 1.0.0"

  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {}

  # Uncomment to specify subscription
  # subscription_id = var.subscription_id
}
'''
        with open(os.path.join(output_dir, 'provider.tf'), 'w') as f:
            f.write(content)

    def _generate_variables(self, output_dir: str) -> None:
        """Generate variables file"""
        vm_size = self.get_recommended_vm_size()
        disk_size = self.get_disk_size()
        # Sanitize hostname for Azure naming
        safe_name = self.hostname.lower().replace('_', '-').replace('.', '-')[:15]

        content = f'''# Variables for Azure Infrastructure
# Generated by System Analyzer

variable "subscription_id" {{
  description = "Azure subscription ID"
  type        = string
  default     = ""
}}

variable "location" {{
  description = "Azure region"
  type        = string
  default     = "eastus"
}}

variable "resource_group_name" {{
  description = "Resource group name"
  type        = string
  default     = "{safe_name}-rg"
}}

variable "vm_name" {{
  description = "Virtual machine name"
  type        = string
  default     = "{safe_name}"
}}

variable "vm_size" {{
  description = "Azure VM size"
  type        = string
  default     = "{vm_size}"
}}

variable "os_disk_size_gb" {{
  description = "OS disk size in GB"
  type        = number
  default     = {disk_size}
}}

variable "os_disk_type" {{
  description = "OS disk storage type"
  type        = string
  default     = "Premium_LRS"
}}

variable "admin_username" {{
  description = "Admin username"
  type        = string
  default     = "azureuser"
}}

variable "ssh_public_key_file" {{
  description = "Path to SSH public key"
  type        = string
  default     = "~/.ssh/id_rsa.pub"
}}

variable "vnet_address_space" {{
  description = "Virtual network address space"
  type        = list(string)
  default     = ["10.0.0.0/16"]
}}

variable "subnet_address_prefixes" {{
  description = "Subnet address prefixes"
  type        = list(string)
  default     = ["10.0.1.0/24"]
}}

variable "enable_public_ip" {{
  description = "Enable public IP address"
  type        = bool
  default     = true
}}

variable "tags" {{
  description = "Tags to apply to resources"
  type        = map(string)
  default     = {{}}
}}
'''
        with open(os.path.join(output_dir, 'variables.tf'), 'w') as f:
            f.write(content)

    def _generate_main(self, output_dir: str) -> None:
        """Generate main Terraform configuration"""
        nsg_rules = self._get_nsg_rules()

        nsg_rules_block = ""
        for rule in nsg_rules:
            nsg_rules_block += f'''
  security_rule {{
    name                       = "{rule['name']}"
    priority                   = {rule['priority']}
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "{rule['protocol']}"
    source_port_range          = "*"
    destination_port_range     = "{rule['port']}"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
    description                = "{rule['description']}"
  }}
'''

        content = f'''# Main Azure Infrastructure
# Generated by System Analyzer for: {self.hostname}

# Resource Group
resource "azurerm_resource_group" "main" {{
  name     = var.resource_group_name
  location = var.location

  tags = merge(var.tags, {{
    ManagedBy = "terraform"
  }})
}}

# Virtual Network
resource "azurerm_virtual_network" "main" {{
  name                = "${{var.vm_name}}-vnet"
  address_space       = var.vnet_address_space
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name

  tags = var.tags
}}

# Subnet
resource "azurerm_subnet" "main" {{
  name                 = "${{var.vm_name}}-subnet"
  resource_group_name  = azurerm_resource_group.main.name
  virtual_network_name = azurerm_virtual_network.main.name
  address_prefixes     = var.subnet_address_prefixes
}}

# Network Security Group
resource "azurerm_network_security_group" "main" {{
  name                = "${{var.vm_name}}-nsg"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
{nsg_rules_block}
  tags = var.tags
}}

# Public IP
resource "azurerm_public_ip" "main" {{
  count               = var.enable_public_ip ? 1 : 0
  name                = "${{var.vm_name}}-pip"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  allocation_method   = "Static"
  sku                 = "Standard"

  tags = var.tags
}}

# Network Interface
resource "azurerm_network_interface" "main" {{
  name                = "${{var.vm_name}}-nic"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name

  ip_configuration {{
    name                          = "internal"
    subnet_id                     = azurerm_subnet.main.id
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id          = var.enable_public_ip ? azurerm_public_ip.main[0].id : null
  }}

  tags = var.tags
}}

# Associate NSG with NIC
resource "azurerm_network_interface_security_group_association" "main" {{
  network_interface_id      = azurerm_network_interface.main.id
  network_security_group_id = azurerm_network_security_group.main.id
}}

# Virtual Machine
resource "azurerm_linux_virtual_machine" "main" {{
  name                = var.vm_name
  resource_group_name = azurerm_resource_group.main.name
  location            = azurerm_resource_group.main.location
  size                = var.vm_size
  admin_username      = var.admin_username

  network_interface_ids = [
    azurerm_network_interface.main.id
  ]

  admin_ssh_key {{
    username   = var.admin_username
    public_key = file(var.ssh_public_key_file)
  }}

  os_disk {{
    caching              = "ReadWrite"
    storage_account_type = var.os_disk_type
    disk_size_gb         = var.os_disk_size_gb
  }}

  source_image_reference {{
    publisher = "Canonical"
    offer     = "0001-com-ubuntu-server-jammy"
    sku       = "22_04-lts-gen2"
    version   = "latest"
  }}

  custom_data = base64encode(file("${{path.module}}/cloud-init.yml"))

  tags = var.tags
}}
'''
        with open(os.path.join(output_dir, 'main.tf'), 'w') as f:
            f.write(content)

    def _generate_outputs(self, output_dir: str) -> None:
        """Generate outputs file"""
        content = '''# Outputs
# Generated by System Analyzer

output "resource_group_name" {
  description = "Resource group name"
  value       = azurerm_resource_group.main.name
}

output "vm_id" {
  description = "Virtual machine ID"
  value       = azurerm_linux_virtual_machine.main.id
}

output "vm_name" {
  description = "Virtual machine name"
  value       = azurerm_linux_virtual_machine.main.name
}

output "private_ip" {
  description = "Private IP address"
  value       = azurerm_network_interface.main.private_ip_address
}

output "public_ip" {
  description = "Public IP address"
  value       = var.enable_public_ip ? azurerm_public_ip.main[0].ip_address : null
}

output "ssh_command" {
  description = "SSH command to connect"
  value       = var.enable_public_ip ? "ssh ${var.admin_username}@${azurerm_public_ip.main[0].ip_address}" : "ssh ${var.admin_username}@${azurerm_network_interface.main.private_ip_address}"
}

output "admin_username" {
  description = "Admin username"
  value       = var.admin_username
}
'''
        with open(os.path.join(output_dir, 'outputs.tf'), 'w') as f:
            f.write(content)

    def _generate_cloud_init(self, output_dir: str) -> None:
        """Generate cloud-init configuration"""
        packages = self._get_packages()

        package_list = "\n".join([f"  - {pkg}" for pkg in packages[:30]]) if packages else "  - htop"

        content = f'''#cloud-config
# Cloud-init for {self.hostname}
# Generated by System Analyzer

package_update: true
package_upgrade: true

packages:
  - curl
  - wget
  - vim
  - git
  - htop
  - net-tools
  - ca-certificates
{package_list}

runcmd:
  - echo "Cloud-init completed" >> /var/log/cloud-init-complete.log

final_message: "System ready after $UPTIME seconds"
'''
        with open(os.path.join(output_dir, 'cloud-init.yml'), 'w') as f:
            f.write(content)

    def _generate_tfvars_example(self, output_dir: str) -> None:
        """Generate example tfvars file"""
        safe_name = self.hostname.lower().replace('_', '-').replace('.', '-')[:15]

        content = f'''# Example Terraform variables for Azure
# Copy to terraform.tfvars and fill in values

# subscription_id = "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"

location            = "eastus"
resource_group_name = "{safe_name}-rg"

vm_name = "{safe_name}"
vm_size = "{self.get_recommended_vm_size()}"

os_disk_size_gb = {self.get_disk_size()}
os_disk_type    = "Premium_LRS"

admin_username      = "azureuser"
ssh_public_key_file = "~/.ssh/id_rsa.pub"

vnet_address_space      = ["10.0.0.0/16"]
subnet_address_prefixes = ["10.0.1.0/24"]

enable_public_ip = true

tags = {{
  Environment = "production"
  Project     = "{self.hostname}"
}}
'''
        with open(os.path.join(output_dir, 'terraform.tfvars.example'), 'w') as f:
            f.write(content)

    def _get_packages(self) -> List[str]:
        """Get list of packages to install"""
        packages = []
        installed = self.data.get('files', {}).get('installed_packages', [])

        for pkg in installed:
            if pkg.get('manager') in ['apt', 'dpkg']:
                name = pkg.get('name', '')
                if name and not any(x in name for x in ['linux-', 'libc', 'base-', 'ubuntu-']):
                    packages.append(name)

        return list(dict.fromkeys(packages))[:50]
