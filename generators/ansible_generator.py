"""
Ansible Generator
Generates Ansible playbooks to configure the system
"""

import logging
import os
import re
from typing import Dict, List, Any

import yaml

logger = logging.getLogger(__name__)


class AnsibleGenerator:
    """Generates Ansible playbooks and roles"""

    def __init__(self, analysis_data: Dict[str, Any]):
        self.data = analysis_data
        self.hostname = analysis_data.get('hostname', 'server')

    def generate(self, output_dir: str) -> str:
        """Generate all Ansible files"""
        os.makedirs(output_dir, exist_ok=True)
        os.makedirs(os.path.join(output_dir, 'roles'), exist_ok=True)
        os.makedirs(os.path.join(output_dir, 'group_vars'), exist_ok=True)
        os.makedirs(os.path.join(output_dir, 'host_vars'), exist_ok=True)

        self._generate_inventory(output_dir)
        self._generate_site_playbook(output_dir)
        self._generate_group_vars(output_dir)
        self._generate_roles(output_dir)
        self._generate_ansible_cfg(output_dir)

        logger.info(f"Ansible configuration generated in: {output_dir}")
        return output_dir

    def _get_packages(self) -> Dict[str, List[str]]:
        """Extract package lists from analysis"""
        packages = {
            'apt': [],
            'pip': [],
            'npm': []
        }

        # From installed packages
        installed = self.data.get('files', {}).get('installed_packages', [])
        for pkg in installed:
            manager = pkg.get('manager', '').lower()
            name = pkg.get('name', '')
            if manager in packages and name:
                packages[manager].append(name)

        # From history
        history = self.data.get('history', {})
        pkg_installs = history.get('package_installations', [])

        for cmd in pkg_installs:
            command = cmd.get('command', '')

            # apt/apt-get install
            match = re.search(r'(?:apt|apt-get)\s+install\s+(?:-y\s+)?(.+)', command)
            if match:
                pkgs = [p for p in match.group(1).split() if not p.startswith('-')]
                packages['apt'].extend(pkgs)

            # pip install
            match = re.search(r'pip3?\s+install\s+(.+)', command)
            if match:
                pkgs = [p for p in match.group(1).split() if not p.startswith('-')]
                packages['pip'].extend(pkgs)

        # Deduplicate
        for key in packages:
            packages[key] = list(dict.fromkeys(packages[key]))

        return packages

    def _get_services(self) -> List[str]:
        """Get list of services to enable"""
        services = []

        for svc in self.data.get('processes', {}).get('services', []):
            if svc.get('active') == 'active' and svc.get('status') == 'running':
                name = svc.get('name', '')
                # Filter common system services
                if name and not any(x in name for x in ['dbus', 'systemd', 'getty', 'user@']):
                    services.append(name)

        return services[:20]  # Limit to 20

    def _generate_inventory(self, output_dir: str) -> None:
        """Generate inventory file"""
        content = f'''# Ansible Inventory
# Generated by System Analyzer

[servers]
{self.hostname} ansible_host={{{{ vm_ip_address }}}} ansible_user={{{{ ssh_user }}}}

[servers:vars]
ansible_python_interpreter=/usr/bin/python3
ansible_ssh_private_key_file={{{{ ssh_private_key_path }}}}
'''

        with open(os.path.join(output_dir, 'inventory'), 'w') as f:
            f.write(content)

    def _generate_site_playbook(self, output_dir: str) -> None:
        """Generate main site.yml playbook"""
        playbook = [
            {
                'name': f'Configure {self.hostname}',
                'hosts': 'servers',
                'become': True,
                'vars_files': [
                    'group_vars/all.yml'
                ],
                'roles': [
                    'common',
                    'packages',
                    'services',
                    'firewall',
                    'users'
                ]
            }
        ]

        with open(os.path.join(output_dir, 'site.yml'), 'w') as f:
            yaml.dump(playbook, f, default_flow_style=False, sort_keys=False)

    def _generate_group_vars(self, output_dir: str) -> None:
        """Generate group variables"""
        packages = self._get_packages()
        services = self._get_services()
        listening_ports = self.data.get('processes', {}).get('listening_ports', [])

        vars_content = {
            'hostname': self.hostname,
            'timezone': 'UTC',
            'apt_packages': packages['apt'][:50],  # Limit
            'pip_packages': packages['pip'][:30],
            'services_to_enable': services,
            'firewall_allowed_ports': list(set([
                p.get('port') for p in listening_ports
                if p.get('port') and 0 < p.get('port') < 65535
            ]))[:20],
            'ssh_user': 'ubuntu',
            'ssh_private_key_path': '~/.ssh/id_rsa'
        }

        with open(os.path.join(output_dir, 'group_vars', 'all.yml'), 'w') as f:
            yaml.dump(vars_content, f, default_flow_style=False, sort_keys=False)

    def _generate_roles(self, output_dir: str) -> None:
        """Generate Ansible roles"""
        roles = ['common', 'packages', 'services', 'firewall', 'users']

        for role in roles:
            role_dir = os.path.join(output_dir, 'roles', role)
            os.makedirs(os.path.join(role_dir, 'tasks'), exist_ok=True)
            os.makedirs(os.path.join(role_dir, 'handlers'), exist_ok=True)
            os.makedirs(os.path.join(role_dir, 'defaults'), exist_ok=True)

            getattr(self, f'_generate_{role}_role')(role_dir)

    def _generate_common_role(self, role_dir: str) -> None:
        """Generate common role"""
        tasks = [
            {
                'name': 'Set hostname',
                'hostname': {
                    'name': '{{ hostname }}'
                }
            },
            {
                'name': 'Set timezone',
                'timezone': {
                    'name': '{{ timezone }}'
                }
            },
            {
                'name': 'Update apt cache',
                'apt': {
                    'update_cache': True,
                    'cache_valid_time': 3600
                }
            },
            {
                'name': 'Upgrade all packages',
                'apt': {
                    'upgrade': 'safe'
                },
                'when': 'upgrade_packages | default(false)'
            },
            {
                'name': 'Install common utilities',
                'apt': {
                    'name': [
                        'curl',
                        'wget',
                        'vim',
                        'git',
                        'htop',
                        'net-tools',
                        'ca-certificates',
                        'gnupg',
                        'lsb-release'
                    ],
                    'state': 'present'
                }
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

    def _generate_packages_role(self, role_dir: str) -> None:
        """Generate packages role"""
        tasks = [
            {
                'name': 'Install apt packages',
                'apt': {
                    'name': '{{ apt_packages }}',
                    'state': 'present'
                },
                'when': 'apt_packages | length > 0'
            },
            {
                'name': 'Install pip',
                'apt': {
                    'name': ['python3-pip', 'python3-venv'],
                    'state': 'present'
                },
                'when': 'pip_packages | length > 0'
            },
            {
                'name': 'Install pip packages',
                'pip': {
                    'name': '{{ pip_packages }}',
                    'state': 'present'
                },
                'when': 'pip_packages | length > 0'
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

    def _generate_services_role(self, role_dir: str) -> None:
        """Generate services role"""
        tasks = [
            {
                'name': 'Enable and start services',
                'systemd': {
                    'name': '{{ item }}',
                    'enabled': True,
                    'state': 'started'
                },
                'loop': '{{ services_to_enable }}',
                'ignore_errors': True
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        handlers = [
            {
                'name': 'restart services',
                'systemd': {
                    'name': '{{ item }}',
                    'state': 'restarted'
                },
                'loop': '{{ services_to_enable }}'
            }
        ]

        with open(os.path.join(role_dir, 'handlers', 'main.yml'), 'w') as f:
            yaml.dump(handlers, f, default_flow_style=False, sort_keys=False)

    def _generate_firewall_role(self, role_dir: str) -> None:
        """Generate firewall role"""
        tasks = [
            {
                'name': 'Install UFW',
                'apt': {
                    'name': 'ufw',
                    'state': 'present'
                }
            },
            {
                'name': 'Allow SSH',
                'ufw': {
                    'rule': 'allow',
                    'port': '22',
                    'proto': 'tcp'
                }
            },
            {
                'name': 'Allow configured ports',
                'ufw': {
                    'rule': 'allow',
                    'port': '{{ item }}',
                    'proto': 'tcp'
                },
                'loop': '{{ firewall_allowed_ports }}'
            },
            {
                'name': 'Enable UFW',
                'ufw': {
                    'state': 'enabled',
                    'policy': 'deny',
                    'direction': 'incoming'
                }
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

    def _generate_users_role(self, role_dir: str) -> None:
        """Generate users role"""
        tasks = [
            {
                'name': 'Ensure admin group exists',
                'group': {
                    'name': 'admin',
                    'state': 'present'
                }
            },
            {
                'name': 'Create deploy user',
                'user': {
                    'name': 'deploy',
                    'groups': 'admin,sudo',
                    'shell': '/bin/bash',
                    'create_home': True
                }
            },
            {
                'name': 'Set up authorized keys for deploy user',
                'authorized_key': {
                    'user': 'deploy',
                    'state': 'present',
                    'key': "{{ lookup('file', ssh_public_key_path) }}"
                },
                'when': 'ssh_public_key_path is defined'
            }
        ]

        with open(os.path.join(role_dir, 'tasks', 'main.yml'), 'w') as f:
            yaml.dump(tasks, f, default_flow_style=False, sort_keys=False)

        defaults = {
            'ssh_public_key_path': '~/.ssh/id_rsa.pub'
        }

        with open(os.path.join(role_dir, 'defaults', 'main.yml'), 'w') as f:
            yaml.dump(defaults, f, default_flow_style=False, sort_keys=False)

    def _generate_ansible_cfg(self, output_dir: str) -> None:
        """Generate ansible.cfg"""
        content = '''[defaults]
inventory = inventory
remote_user = ubuntu
private_key_file = ~/.ssh/id_rsa
host_key_checking = False
retry_files_enabled = False
gathering = smart
fact_caching = jsonfile
fact_caching_connection = /tmp/ansible_facts
fact_caching_timeout = 86400

[privilege_escalation]
become = True
become_method = sudo
become_user = root
become_ask_pass = False

[ssh_connection]
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s
'''

        with open(os.path.join(output_dir, 'ansible.cfg'), 'w') as f:
            f.write(content)
