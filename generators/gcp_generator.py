"""
GCP Terraform Generator
Generates Terraform configurations for Google Cloud Compute Engine
"""

import json
import logging
import os
from typing import Dict, List, Any

logger = logging.getLogger(__name__)


class GCPGenerator:
    """Generates Terraform configurations for Google Cloud Platform"""

    # Machine type mapping based on CPU/memory
    MACHINE_TYPES = [
        {'vcpus': 1, 'memory_gb': 1, 'type': 'e2-micro'},
        {'vcpus': 2, 'memory_gb': 2, 'type': 'e2-small'},
        {'vcpus': 2, 'memory_gb': 4, 'type': 'e2-medium'},
        {'vcpus': 2, 'memory_gb': 8, 'type': 'e2-standard-2'},
        {'vcpus': 4, 'memory_gb': 16, 'type': 'e2-standard-4'},
        {'vcpus': 8, 'memory_gb': 32, 'type': 'e2-standard-8'},
        {'vcpus': 16, 'memory_gb': 64, 'type': 'e2-standard-16'},
        {'vcpus': 32, 'memory_gb': 128, 'type': 'e2-standard-32'},
        {'vcpus': 4, 'memory_gb': 32, 'type': 'e2-highmem-4'},
        {'vcpus': 8, 'memory_gb': 64, 'type': 'e2-highmem-8'},
        {'vcpus': 16, 'memory_gb': 128, 'type': 'e2-highmem-16'},
    ]

    def __init__(self, analysis_data: Dict[str, Any]):
        self.data = analysis_data
        self.hostname = analysis_data.get('hostname', 'server')

    def generate(self, output_dir: str) -> str:
        """Generate all GCP Terraform files"""
        os.makedirs(output_dir, exist_ok=True)

        self._generate_provider(output_dir)
        self._generate_variables(output_dir)
        self._generate_main(output_dir)
        self._generate_outputs(output_dir)
        self._generate_startup_script(output_dir)
        self._generate_tfvars_example(output_dir)

        logger.info(f"GCP Terraform configuration generated in: {output_dir}")
        return output_dir

    def get_recommended_machine_type(self) -> str:
        """Determine the best GCP machine type based on system specs"""
        resources = self.data.get('processes', {}).get('resource_usage', {})
        cpu = resources.get('cpu', {})
        memory = resources.get('memory', {})

        vcpus = cpu.get('count', 2)
        memory_bytes = memory.get('total', 4 * 1024 * 1024 * 1024)
        memory_gb = memory_bytes / (1024 ** 3)

        best_match = 'e2-medium'  # Default
        for inst in self.MACHINE_TYPES:
            if inst['vcpus'] >= vcpus and inst['memory_gb'] >= memory_gb:
                best_match = inst['type']
                break

        return best_match

    def get_disk_size(self) -> int:
        """Get required disk size in GB"""
        resources = self.data.get('processes', {}).get('resource_usage', {})
        disk = resources.get('disk', {})

        total_bytes = 0
        for mount, usage in disk.items():
            if mount == '/' or mount.startswith('/home'):
                total_bytes += usage.get('used', 0)

        disk_gb = max(20, int((total_bytes / (1024 ** 3)) * 1.5))
        return disk_gb

    def _get_firewall_rules(self) -> List[Dict]:
        """Generate firewall rules based on listening ports"""
        rules = []
        listening = self.data.get('processes', {}).get('listening_ports', [])

        # Always allow SSH
        rules.append({
            'name': 'allow-ssh',
            'ports': ['22'],
            'protocol': 'tcp',
            'description': 'Allow SSH access'
        })

        # Group ports by common services
        web_ports = []
        db_ports = []
        other_ports = []

        for port_info in listening:
            port = port_info.get('port', 0)
            if port in [22]:
                continue
            if port in [80, 443, 8080, 8443]:
                web_ports.append(str(port))
            elif port in [3306, 5432, 27017, 6379]:
                db_ports.append(str(port))
            elif port > 0 and port < 65536:
                other_ports.append(str(port))

        if web_ports:
            rules.append({
                'name': 'allow-web',
                'ports': web_ports,
                'protocol': 'tcp',
                'description': 'Allow web traffic'
            })

        if db_ports:
            rules.append({
                'name': 'allow-db',
                'ports': db_ports,
                'protocol': 'tcp',
                'description': 'Allow database access'
            })

        if other_ports:
            rules.append({
                'name': 'allow-custom',
                'ports': other_ports[:10],  # Limit
                'protocol': 'tcp',
                'description': 'Allow custom ports'
            })

        return rules

    def _generate_provider(self, output_dir: str) -> None:
        """Generate GCP provider configuration"""
        content = '''# GCP Provider Configuration
# Generated by System Analyzer

terraform {
  required_version = ">= 1.0.0"

  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
  zone    = var.zone
}
'''
        with open(os.path.join(output_dir, 'provider.tf'), 'w') as f:
            f.write(content)

    def _generate_variables(self, output_dir: str) -> None:
        """Generate variables file"""
        machine_type = self.get_recommended_machine_type()
        disk_size = self.get_disk_size()

        content = f'''# Variables for GCP Infrastructure
# Generated by System Analyzer

variable "project_id" {{
  description = "GCP project ID"
  type        = string
}}

variable "region" {{
  description = "GCP region"
  type        = string
  default     = "us-central1"
}}

variable "zone" {{
  description = "GCP zone"
  type        = string
  default     = "us-central1-a"
}}

variable "instance_name" {{
  description = "Name for the Compute Engine instance"
  type        = string
  default     = "{self.hostname.lower().replace('_', '-')}"
}}

variable "machine_type" {{
  description = "GCP machine type"
  type        = string
  default     = "{machine_type}"
}}

variable "boot_disk_size" {{
  description = "Boot disk size in GB"
  type        = number
  default     = {disk_size}
}}

variable "boot_disk_type" {{
  description = "Boot disk type"
  type        = string
  default     = "pd-ssd"
}}

variable "image_family" {{
  description = "OS image family"
  type        = string
  default     = "ubuntu-2204-lts"
}}

variable "image_project" {{
  description = "OS image project"
  type        = string
  default     = "ubuntu-os-cloud"
}}

variable "network" {{
  description = "VPC network name"
  type        = string
  default     = "default"
}}

variable "subnetwork" {{
  description = "Subnetwork name (optional)"
  type        = string
  default     = ""
}}

variable "enable_public_ip" {{
  description = "Enable external IP address"
  type        = bool
  default     = true
}}

variable "ssh_user" {{
  description = "SSH username"
  type        = string
  default     = "ubuntu"
}}

variable "ssh_pub_key_file" {{
  description = "Path to SSH public key file"
  type        = string
  default     = "~/.ssh/id_rsa.pub"
}}

variable "labels" {{
  description = "Labels to apply"
  type        = map(string)
  default     = {{}}
}}
'''
        with open(os.path.join(output_dir, 'variables.tf'), 'w') as f:
            f.write(content)

    def _generate_main(self, output_dir: str) -> None:
        """Generate main Terraform configuration"""
        firewall_rules = self._get_firewall_rules()

        firewall_resources = ""
        for rule in firewall_rules:
            firewall_resources += f'''
resource "google_compute_firewall" "{rule['name'].replace('-', '_')}" {{
  name    = "${{var.instance_name}}-{rule['name']}"
  network = var.network

  allow {{
    protocol = "{rule['protocol']}"
    ports    = {json.dumps(rule['ports'])}
  }}

  source_ranges = ["0.0.0.0/0"]
  target_tags   = [var.instance_name]
  description   = "{rule['description']}"
}}
'''

        content = f'''# Main GCP Infrastructure
# Generated by System Analyzer for: {self.hostname}

# Data source for latest image
data "google_compute_image" "ubuntu" {{
  family  = var.image_family
  project = var.image_project
}}

# Service Account
resource "google_service_account" "main" {{
  account_id   = "${{var.instance_name}}-sa"
  display_name = "Service account for ${{var.instance_name}}"
}}

# Firewall Rules
{firewall_resources}

# Compute Instance
resource "google_compute_instance" "main" {{
  name         = var.instance_name
  machine_type = var.machine_type
  zone         = var.zone

  tags = [var.instance_name]

  boot_disk {{
    initialize_params {{
      image = data.google_compute_image.ubuntu.self_link
      size  = var.boot_disk_size
      type  = var.boot_disk_type
    }}
  }}

  network_interface {{
    network    = var.network
    subnetwork = var.subnetwork != "" ? var.subnetwork : null

    dynamic "access_config" {{
      for_each = var.enable_public_ip ? [1] : []
      content {{
        // Ephemeral public IP
      }}
    }}
  }}

  metadata = {{
    ssh-keys = "${{var.ssh_user}}:${{file(var.ssh_pub_key_file)}}"
  }}

  metadata_startup_script = file("${{path.module}}/startup-script.sh")

  service_account {{
    email  = google_service_account.main.email
    scopes = ["cloud-platform"]
  }}

  labels = merge(var.labels, {{
    managed_by = "terraform"
  }})

  allow_stopping_for_update = true
}}

# Static IP (optional)
resource "google_compute_address" "static" {{
  count  = var.enable_public_ip ? 1 : 0
  name   = "${{var.instance_name}}-ip"
  region = var.region
}}
'''
        with open(os.path.join(output_dir, 'main.tf'), 'w') as f:
            f.write(content)

    def _generate_outputs(self, output_dir: str) -> None:
        """Generate outputs file"""
        content = '''# Outputs
# Generated by System Analyzer

output "instance_id" {
  description = "Instance ID"
  value       = google_compute_instance.main.instance_id
}

output "instance_name" {
  description = "Instance name"
  value       = google_compute_instance.main.name
}

output "internal_ip" {
  description = "Internal IP address"
  value       = google_compute_instance.main.network_interface[0].network_ip
}

output "external_ip" {
  description = "External IP address"
  value       = var.enable_public_ip ? google_compute_instance.main.network_interface[0].access_config[0].nat_ip : null
}

output "service_account" {
  description = "Service account email"
  value       = google_service_account.main.email
}

output "ssh_command" {
  description = "SSH command to connect"
  value       = var.enable_public_ip ? "gcloud compute ssh ${var.ssh_user}@${google_compute_instance.main.name} --zone=${var.zone}" : "Use IAP or internal network"
}
'''
        with open(os.path.join(output_dir, 'outputs.tf'), 'w') as f:
            f.write(content)

    def _generate_startup_script(self, output_dir: str) -> None:
        """Generate startup script"""
        packages = self._get_packages()

        content = f'''#!/bin/bash
# Startup script for {self.hostname}
# Generated by System Analyzer

set -e

# Log output
exec > >(tee /var/log/startup-script.log) 2>&1

echo "Starting instance configuration..."

# Update system
apt-get update
apt-get upgrade -y

# Install base packages
apt-get install -y \\
    curl \\
    wget \\
    vim \\
    git \\
    htop \\
    net-tools \\
    ca-certificates \\
    google-cloud-cli

'''
        if packages:
            content += f'''# Install detected packages
apt-get install -y \\
    {' '.join(packages[:30])} || true

'''

        content += '''echo "Startup script completed successfully"
'''

        with open(os.path.join(output_dir, 'startup-script.sh'), 'w') as f:
            f.write(content)

    def _generate_tfvars_example(self, output_dir: str) -> None:
        """Generate example tfvars file"""
        content = f'''# Example Terraform variables for GCP
# Copy to terraform.tfvars and fill in values

project_id = "my-gcp-project"
region     = "us-central1"
zone       = "us-central1-a"

instance_name = "{self.hostname.lower().replace('_', '-')}"
machine_type  = "{self.get_recommended_machine_type()}"

boot_disk_size = {self.get_disk_size()}
boot_disk_type = "pd-ssd"

image_family  = "ubuntu-2204-lts"
image_project = "ubuntu-os-cloud"

network    = "default"
# subnetwork = "my-subnet"

enable_public_ip = true

ssh_user         = "ubuntu"
ssh_pub_key_file = "~/.ssh/id_rsa.pub"

labels = {{
  environment = "production"
  team        = "platform"
}}
'''
        with open(os.path.join(output_dir, 'terraform.tfvars.example'), 'w') as f:
            f.write(content)

    def _get_packages(self) -> List[str]:
        """Get list of packages to install"""
        packages = []
        installed = self.data.get('files', {}).get('installed_packages', [])

        for pkg in installed:
            if pkg.get('manager') in ['apt', 'dpkg']:
                name = pkg.get('name', '')
                if name and not any(x in name for x in ['linux-', 'libc', 'base-', 'ubuntu-']):
                    packages.append(name)

        return list(dict.fromkeys(packages))[:50]
