"""
Terraform Generator
Generates Terraform configuration to recreate the system
"""

import json
import logging
import os
from typing import Dict, List, Any

logger = logging.getLogger(__name__)


class TerraformGenerator:
    """Generates Terraform configurations for vSphere"""

    def __init__(self, analysis_data: Dict[str, Any], vsphere_template: str = None):
        self.data = analysis_data
        self.vsphere_template = vsphere_template or 'ubuntu-22.04-template'
        self.hostname = analysis_data.get('hostname', 'server')

    def generate(self, output_dir: str) -> str:
        """Generate all Terraform files"""
        os.makedirs(output_dir, exist_ok=True)

        self._generate_main_tf(output_dir)
        self._generate_variables_tf(output_dir)
        self._generate_terraform_tfvars(output_dir)
        self._generate_outputs_tf(output_dir)
        self._generate_provider_tf(output_dir)

        logger.info(f"Terraform configuration generated in: {output_dir}")
        return output_dir

    def _get_vm_specs(self) -> Dict:
        """Extract VM specifications from analysis"""
        virt = self.data.get('virtualization', {})
        resources = self.data.get('processes', {}).get('resource_usage', {})

        # Default specs
        specs = {
            'name': self.hostname,
            'num_cpus': 2,
            'memory': 4096,
            'disk_size': 50,
            'network': 'VM Network',
            'datastore': 'datastore1',
            'folder': '',
            'guest_id': 'ubuntu64Guest'
        }

        # Try to get from vCenter/Proxmox data
        if virt.get('platform') == 'vcenter':
            vm_data = virt.get('data', {}).get('current_vm', {})
            if vm_data:
                specs.update({
                    'num_cpus': vm_data.get('num_cpu', specs['num_cpus']),
                    'memory': vm_data.get('memory_mb', specs['memory']),
                    'disk_size': vm_data.get('total_disk_gb', specs['disk_size']),
                    'guest_id': vm_data.get('guest_id', specs['guest_id']),
                    'folder': vm_data.get('folder', ''),
                    'datastore': vm_data.get('datastore', ['datastore1'])[0] if vm_data.get('datastore') else 'datastore1'
                })

        elif virt.get('platform') == 'proxmox':
            vm_data = virt.get('data', {}).get('current_vm', {})
            if vm_data:
                specs.update({
                    'num_cpus': vm_data.get('cores', 1) * vm_data.get('sockets', 1),
                    'memory': vm_data.get('memory', specs['memory']),
                    'disk_size': vm_data.get('disk_gb', specs['disk_size'])
                })

        # Use resource usage as fallback
        if resources:
            cpu = resources.get('cpu', {})
            memory = resources.get('memory', {})

            if cpu.get('count'):
                specs['num_cpus'] = cpu['count']
            if memory.get('total'):
                specs['memory'] = int(memory['total'] / 1024 / 1024)  # bytes to MB

        return specs

    def _generate_main_tf(self, output_dir: str) -> None:
        """Generate main.tf"""
        specs = self._get_vm_specs()

        # Get listening ports for firewall rules
        listening_ports = self.data.get('processes', {}).get('listening_ports', [])
        ports = list(set([p.get('port') for p in listening_ports if p.get('port') and p.get('port') < 65535]))

        content = f'''# Terraform configuration for {self.hostname}
# Generated by System Analyzer

terraform {{
  required_version = ">= 1.0.0"

  required_providers {{
    vsphere = {{
      source  = "hashicorp/vsphere"
      version = "~> 2.0"
    }}
  }}
}}

# Data sources
data "vsphere_datacenter" "dc" {{
  name = var.vsphere_datacenter
}}

data "vsphere_compute_cluster" "cluster" {{
  name          = var.vsphere_cluster
  datacenter_id = data.vsphere_datacenter.dc.id
}}

data "vsphere_datastore" "datastore" {{
  name          = var.vsphere_datastore
  datacenter_id = data.vsphere_datacenter.dc.id
}}

data "vsphere_network" "network" {{
  name          = var.vsphere_network
  datacenter_id = data.vsphere_datacenter.dc.id
}}

data "vsphere_virtual_machine" "template" {{
  name          = var.vsphere_template
  datacenter_id = data.vsphere_datacenter.dc.id
}}

# Virtual Machine
resource "vsphere_virtual_machine" "{self.hostname.replace('-', '_').replace('.', '_')}" {{
  name             = var.vm_name
  resource_pool_id = data.vsphere_compute_cluster.cluster.resource_pool_id
  datastore_id     = data.vsphere_datastore.datastore.id

  num_cpus = var.vm_cpus
  memory   = var.vm_memory
  guest_id = data.vsphere_virtual_machine.template.guest_id

  scsi_type = data.vsphere_virtual_machine.template.scsi_type

  network_interface {{
    network_id   = data.vsphere_network.network.id
    adapter_type = data.vsphere_virtual_machine.template.network_interface_types[0]
  }}

  disk {{
    label            = "disk0"
    size             = var.vm_disk_size
    thin_provisioned = data.vsphere_virtual_machine.template.disks.0.thin_provisioned
  }}

  clone {{
    template_uuid = data.vsphere_virtual_machine.template.id

    customize {{
      linux_options {{
        host_name = var.vm_hostname
        domain    = var.vm_domain
      }}

      network_interface {{
        ipv4_address = var.vm_ip_address
        ipv4_netmask = var.vm_netmask
      }}

      ipv4_gateway    = var.vm_gateway
      dns_server_list = var.vm_dns_servers
    }}
  }}

  # Provisioner for Ansible
  provisioner "remote-exec" {{
    inline = ["echo 'SSH connection established'"]

    connection {{
      type        = "ssh"
      host        = self.default_ip_address
      user        = var.ssh_user
      private_key = file(var.ssh_private_key_path)
    }}
  }}

  provisioner "local-exec" {{
    command = "ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -i '${{self.default_ip_address}},' -u ${{var.ssh_user}} --private-key ${{var.ssh_private_key_path}} ../ansible/site.yml"
  }}

  tags = var.vm_tags

  lifecycle {{
    ignore_changes = [
      clone[0].template_uuid,
    ]
  }}
}}

# Output the VM information
output "vm_ip" {{
  value       = vsphere_virtual_machine.{self.hostname.replace('-', '_').replace('.', '_')}.default_ip_address
  description = "The IP address of the VM"
}}
'''

        with open(os.path.join(output_dir, 'main.tf'), 'w') as f:
            f.write(content)

    def _generate_variables_tf(self, output_dir: str) -> None:
        """Generate variables.tf"""
        specs = self._get_vm_specs()

        content = f'''# Variable definitions for {self.hostname}

# vSphere Connection
variable "vsphere_server" {{
  description = "vSphere server address"
  type        = string
}}

variable "vsphere_user" {{
  description = "vSphere username"
  type        = string
}}

variable "vsphere_password" {{
  description = "vSphere password"
  type        = string
  sensitive   = true
}}

# vSphere Infrastructure
variable "vsphere_datacenter" {{
  description = "vSphere datacenter name"
  type        = string
  default     = "Datacenter"
}}

variable "vsphere_cluster" {{
  description = "vSphere cluster name"
  type        = string
  default     = "Cluster"
}}

variable "vsphere_datastore" {{
  description = "vSphere datastore name"
  type        = string
  default     = "{specs['datastore']}"
}}

variable "vsphere_network" {{
  description = "vSphere network name"
  type        = string
  default     = "{specs['network']}"
}}

variable "vsphere_template" {{
  description = "VM template to clone"
  type        = string
  default     = "{self.vsphere_template}"
}}

# VM Configuration
variable "vm_name" {{
  description = "Name of the virtual machine"
  type        = string
  default     = "{self.hostname}"
}}

variable "vm_hostname" {{
  description = "Hostname for the VM"
  type        = string
  default     = "{self.hostname.split('.')[0]}"
}}

variable "vm_domain" {{
  description = "Domain name for the VM"
  type        = string
  default     = "local"
}}

variable "vm_cpus" {{
  description = "Number of CPUs"
  type        = number
  default     = {specs['num_cpus']}
}}

variable "vm_memory" {{
  description = "Memory in MB"
  type        = number
  default     = {specs['memory']}
}}

variable "vm_disk_size" {{
  description = "Disk size in GB"
  type        = number
  default     = {int(specs['disk_size'])}
}}

# Network Configuration
variable "vm_ip_address" {{
  description = "Static IP address for the VM"
  type        = string
}}

variable "vm_netmask" {{
  description = "Network mask (e.g., 24)"
  type        = number
  default     = 24
}}

variable "vm_gateway" {{
  description = "Default gateway"
  type        = string
}}

variable "vm_dns_servers" {{
  description = "DNS servers"
  type        = list(string)
  default     = ["8.8.8.8", "8.8.4.4"]
}}

# SSH Configuration
variable "ssh_user" {{
  description = "SSH user for provisioning"
  type        = string
  default     = "ubuntu"
}}

variable "ssh_private_key_path" {{
  description = "Path to SSH private key"
  type        = string
  default     = "~/.ssh/id_rsa"
}}

# Tags
variable "vm_tags" {{
  description = "Tags to apply to the VM"
  type        = list(string)
  default     = ["managed-by-terraform", "system-analyzer"]
}}
'''

        with open(os.path.join(output_dir, 'variables.tf'), 'w') as f:
            f.write(content)

    def _generate_terraform_tfvars(self, output_dir: str) -> None:
        """Generate terraform.tfvars.example"""
        content = f'''# Example Terraform variables
# Copy this file to terraform.tfvars and fill in the values

# vSphere Connection
vsphere_server   = "vcenter.example.com"
vsphere_user     = "administrator@vsphere.local"
vsphere_password = "your-password-here"

# vSphere Infrastructure
vsphere_datacenter = "Datacenter"
vsphere_cluster    = "Cluster"
vsphere_datastore  = "datastore1"
vsphere_network    = "VM Network"
vsphere_template   = "{self.vsphere_template}"

# VM Configuration
vm_name     = "{self.hostname}"
vm_hostname = "{self.hostname.split('.')[0]}"
vm_domain   = "example.com"

# Network Configuration
vm_ip_address  = "192.168.1.100"
vm_netmask     = 24
vm_gateway     = "192.168.1.1"
vm_dns_servers = ["8.8.8.8", "8.8.4.4"]

# SSH Configuration
ssh_user             = "ubuntu"
ssh_private_key_path = "~/.ssh/id_rsa"
'''

        with open(os.path.join(output_dir, 'terraform.tfvars.example'), 'w') as f:
            f.write(content)

    def _generate_outputs_tf(self, output_dir: str) -> None:
        """Generate outputs.tf"""
        content = f'''# Output definitions for {self.hostname}

output "vm_name" {{
  description = "Name of the created VM"
  value       = vsphere_virtual_machine.{self.hostname.replace('-', '_').replace('.', '_')}.name
}}

output "vm_ip_address" {{
  description = "IP address of the VM"
  value       = vsphere_virtual_machine.{self.hostname.replace('-', '_').replace('.', '_')}.default_ip_address
}}

output "vm_uuid" {{
  description = "UUID of the VM"
  value       = vsphere_virtual_machine.{self.hostname.replace('-', '_').replace('.', '_')}.uuid
}}

output "vm_moid" {{
  description = "Managed Object ID of the VM"
  value       = vsphere_virtual_machine.{self.hostname.replace('-', '_').replace('.', '_')}.moid
}}
'''

        with open(os.path.join(output_dir, 'outputs.tf'), 'w') as f:
            f.write(content)

    def _generate_provider_tf(self, output_dir: str) -> None:
        """Generate provider.tf"""
        content = '''# Provider configuration

provider "vsphere" {
  vsphere_server       = var.vsphere_server
  user                 = var.vsphere_user
  password             = var.vsphere_password
  allow_unverified_ssl = true
}
'''

        with open(os.path.join(output_dir, 'provider.tf'), 'w') as f:
            f.write(content)
