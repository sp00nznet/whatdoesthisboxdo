"""
AWS Terraform Generator
Generates Terraform configurations for AWS EC2 instances
"""

import json
import logging
import os
from typing import Dict, List, Any

logger = logging.getLogger(__name__)


class AWSGenerator:
    """Generates Terraform configurations for AWS"""

    # Instance type mapping based on CPU/memory
    INSTANCE_TYPES = [
        {'vcpus': 1, 'memory_gb': 1, 'type': 't3.micro'},
        {'vcpus': 2, 'memory_gb': 2, 'type': 't3.small'},
        {'vcpus': 2, 'memory_gb': 4, 'type': 't3.medium'},
        {'vcpus': 2, 'memory_gb': 8, 'type': 't3.large'},
        {'vcpus': 4, 'memory_gb': 16, 'type': 't3.xlarge'},
        {'vcpus': 8, 'memory_gb': 32, 'type': 't3.2xlarge'},
        {'vcpus': 4, 'memory_gb': 32, 'type': 'r6i.xlarge'},
        {'vcpus': 8, 'memory_gb': 64, 'type': 'r6i.2xlarge'},
        {'vcpus': 16, 'memory_gb': 64, 'type': 'm6i.4xlarge'},
        {'vcpus': 32, 'memory_gb': 128, 'type': 'm6i.8xlarge'},
        {'vcpus': 48, 'memory_gb': 192, 'type': 'm6i.12xlarge'},
        {'vcpus': 64, 'memory_gb': 256, 'type': 'm6i.16xlarge'},
    ]

    def __init__(self, analysis_data: Dict[str, Any]):
        self.data = analysis_data
        self.hostname = analysis_data.get('hostname', 'server')

    def generate(self, output_dir: str) -> str:
        """Generate all AWS Terraform files"""
        os.makedirs(output_dir, exist_ok=True)

        self._generate_provider(output_dir)
        self._generate_variables(output_dir)
        self._generate_main(output_dir)
        self._generate_outputs(output_dir)
        self._generate_userdata(output_dir)
        self._generate_tfvars_example(output_dir)

        logger.info(f"AWS Terraform configuration generated in: {output_dir}")
        return output_dir

    def get_recommended_instance_type(self) -> str:
        """Determine the best EC2 instance type based on system specs"""
        resources = self.data.get('processes', {}).get('resource_usage', {})
        cpu = resources.get('cpu', {})
        memory = resources.get('memory', {})

        vcpus = cpu.get('count', 2)
        memory_bytes = memory.get('total', 4 * 1024 * 1024 * 1024)
        memory_gb = memory_bytes / (1024 ** 3)

        # Find best matching instance type
        best_match = 't3.medium'  # Default
        for inst in self.INSTANCE_TYPES:
            if inst['vcpus'] >= vcpus and inst['memory_gb'] >= memory_gb:
                best_match = inst['type']
                break

        return best_match

    def get_disk_size(self) -> int:
        """Get required disk size in GB"""
        resources = self.data.get('processes', {}).get('resource_usage', {})
        disk = resources.get('disk', {})

        total_bytes = 0
        for mount, usage in disk.items():
            if mount == '/' or mount.startswith('/home'):
                total_bytes += usage.get('used', 0)

        # Add 50% buffer, minimum 20GB
        disk_gb = max(20, int((total_bytes / (1024 ** 3)) * 1.5))
        return disk_gb

    def _get_security_group_rules(self) -> List[Dict]:
        """Generate security group rules based on listening ports"""
        rules = []
        listening = self.data.get('processes', {}).get('listening_ports', [])

        # Always allow SSH
        rules.append({
            'from_port': 22,
            'to_port': 22,
            'protocol': 'tcp',
            'cidr_blocks': ['0.0.0.0/0'],
            'description': 'SSH access'
        })

        # Add rules for detected ports
        for port_info in listening:
            port = port_info.get('port', 0)
            process = port_info.get('process', 'unknown')

            if port in [22]:  # Skip already added
                continue
            if port > 0 and port < 65536:
                rules.append({
                    'from_port': port,
                    'to_port': port,
                    'protocol': 'tcp',
                    'cidr_blocks': ['0.0.0.0/0'],
                    'description': f'{process} on port {port}'
                })

        return rules[:20]  # Limit to 20 rules

    def _generate_provider(self, output_dir: str) -> None:
        """Generate AWS provider configuration"""
        content = '''# AWS Provider Configuration
# Generated by System Analyzer

terraform {
  required_version = ">= 1.0.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      Environment = var.environment
      ManagedBy   = "terraform"
      Project     = var.project_name
    }
  }
}
'''
        with open(os.path.join(output_dir, 'provider.tf'), 'w') as f:
            f.write(content)

    def _generate_variables(self, output_dir: str) -> None:
        """Generate variables file"""
        instance_type = self.get_recommended_instance_type()
        disk_size = self.get_disk_size()

        content = f'''# Variables for AWS Infrastructure
# Generated by System Analyzer

variable "aws_region" {{
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}}

variable "environment" {{
  description = "Environment name"
  type        = string
  default     = "production"
}}

variable "project_name" {{
  description = "Project name for tagging"
  type        = string
  default     = "{self.hostname}"
}}

variable "instance_name" {{
  description = "Name for the EC2 instance"
  type        = string
  default     = "{self.hostname}"
}}

variable "instance_type" {{
  description = "EC2 instance type"
  type        = string
  default     = "{instance_type}"
}}

variable "root_volume_size" {{
  description = "Root volume size in GB"
  type        = number
  default     = {disk_size}
}}

variable "root_volume_type" {{
  description = "Root volume type"
  type        = string
  default     = "gp3"
}}

variable "ami_id" {{
  description = "AMI ID (leave empty for latest Ubuntu 22.04)"
  type        = string
  default     = ""
}}

variable "vpc_id" {{
  description = "VPC ID (leave empty to use default VPC)"
  type        = string
  default     = ""
}}

variable "subnet_id" {{
  description = "Subnet ID (leave empty for auto-selection)"
  type        = string
  default     = ""
}}

variable "key_name" {{
  description = "SSH key pair name"
  type        = string
}}

variable "associate_public_ip" {{
  description = "Associate public IP address"
  type        = bool
  default     = true
}}

variable "allowed_ssh_cidrs" {{
  description = "CIDR blocks allowed for SSH"
  type        = list(string)
  default     = ["0.0.0.0/0"]
}}
'''
        with open(os.path.join(output_dir, 'variables.tf'), 'w') as f:
            f.write(content)

    def _generate_main(self, output_dir: str) -> None:
        """Generate main Terraform configuration"""
        sg_rules = self._get_security_group_rules()

        ingress_rules = ""
        for rule in sg_rules:
            ingress_rules += f'''
  ingress {{
    from_port   = {rule['from_port']}
    to_port     = {rule['to_port']}
    protocol    = "{rule['protocol']}"
    cidr_blocks = {json.dumps(rule['cidr_blocks'])}
    description = "{rule['description']}"
  }}
'''

        content = f'''# Main AWS Infrastructure
# Generated by System Analyzer for: {self.hostname}

# Data sources
data "aws_vpc" "selected" {{
  id      = var.vpc_id != "" ? var.vpc_id : null
  default = var.vpc_id == "" ? true : null
}}

data "aws_subnets" "available" {{
  filter {{
    name   = "vpc-id"
    values = [data.aws_vpc.selected.id]
  }}
}}

data "aws_ami" "ubuntu" {{
  most_recent = true
  owners      = ["099720109477"] # Canonical

  filter {{
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]
  }}

  filter {{
    name   = "virtualization-type"
    values = ["hvm"]
  }}
}}

# Security Group
resource "aws_security_group" "main" {{
  name        = "${{var.instance_name}}-sg"
  description = "Security group for ${{var.instance_name}}"
  vpc_id      = data.aws_vpc.selected.id
{ingress_rules}
  egress {{
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "Allow all outbound"
  }}

  tags = {{
    Name = "${{var.instance_name}}-sg"
  }}
}}

# EC2 Instance
resource "aws_instance" "main" {{
  ami                    = var.ami_id != "" ? var.ami_id : data.aws_ami.ubuntu.id
  instance_type          = var.instance_type
  key_name               = var.key_name
  vpc_security_group_ids = [aws_security_group.main.id]
  subnet_id              = var.subnet_id != "" ? var.subnet_id : data.aws_subnets.available.ids[0]

  associate_public_ip_address = var.associate_public_ip

  root_block_device {{
    volume_size           = var.root_volume_size
    volume_type           = var.root_volume_type
    encrypted             = true
    delete_on_termination = true
  }}

  user_data = file("${{path.module}}/userdata.sh")

  tags = {{
    Name = var.instance_name
  }}

  lifecycle {{
    ignore_changes = [ami]
  }}
}}

# Elastic IP (optional)
resource "aws_eip" "main" {{
  count    = var.associate_public_ip ? 1 : 0
  instance = aws_instance.main.id
  domain   = "vpc"

  tags = {{
    Name = "${{var.instance_name}}-eip"
  }}
}}
'''
        with open(os.path.join(output_dir, 'main.tf'), 'w') as f:
            f.write(content)

    def _generate_outputs(self, output_dir: str) -> None:
        """Generate outputs file"""
        content = '''# Outputs
# Generated by System Analyzer

output "instance_id" {
  description = "EC2 instance ID"
  value       = aws_instance.main.id
}

output "private_ip" {
  description = "Private IP address"
  value       = aws_instance.main.private_ip
}

output "public_ip" {
  description = "Public IP address"
  value       = var.associate_public_ip ? aws_eip.main[0].public_ip : aws_instance.main.public_ip
}

output "security_group_id" {
  description = "Security group ID"
  value       = aws_security_group.main.id
}

output "ssh_command" {
  description = "SSH command to connect"
  value       = "ssh -i ~/.ssh/${var.key_name}.pem ubuntu@${var.associate_public_ip ? aws_eip.main[0].public_ip : aws_instance.main.public_ip}"
}
'''
        with open(os.path.join(output_dir, 'outputs.tf'), 'w') as f:
            f.write(content)

    def _generate_userdata(self, output_dir: str) -> None:
        """Generate userdata script"""
        packages = self._get_packages()

        content = f'''#!/bin/bash
# Userdata script for {self.hostname}
# Generated by System Analyzer

set -e

# Update system
apt-get update
apt-get upgrade -y

# Install packages
apt-get install -y \\
    curl \\
    wget \\
    vim \\
    git \\
    htop \\
    net-tools \\
    ca-certificates

'''
        if packages:
            content += f'''# Install detected packages
apt-get install -y \\
    {' '.join(packages[:30])} || true

'''

        content += '''# Signal completion
echo "Userdata script completed" > /var/log/userdata-complete.log
'''

        with open(os.path.join(output_dir, 'userdata.sh'), 'w') as f:
            f.write(content)

    def _generate_tfvars_example(self, output_dir: str) -> None:
        """Generate example tfvars file"""
        content = f'''# Example Terraform variables for AWS
# Copy to terraform.tfvars and fill in values

aws_region   = "us-east-1"
environment  = "production"
project_name = "{self.hostname}"

instance_name = "{self.hostname}"
instance_type = "{self.get_recommended_instance_type()}"

root_volume_size = {self.get_disk_size()}
root_volume_type = "gp3"

# Required: SSH key pair name (must exist in AWS)
key_name = "my-key-pair"

# Optional: Specify VPC/Subnet (uses default if empty)
# vpc_id    = "vpc-xxxxxxxx"
# subnet_id = "subnet-xxxxxxxx"

associate_public_ip = true
allowed_ssh_cidrs   = ["0.0.0.0/0"]  # Restrict in production!
'''
        with open(os.path.join(output_dir, 'terraform.tfvars.example'), 'w') as f:
            f.write(content)

    def _get_packages(self) -> List[str]:
        """Get list of packages to install"""
        packages = []
        installed = self.data.get('files', {}).get('installed_packages', [])

        for pkg in installed:
            if pkg.get('manager') in ['apt', 'dpkg']:
                name = pkg.get('name', '')
                if name and not any(x in name for x in ['linux-', 'libc', 'base-', 'ubuntu-']):
                    packages.append(name)

        return list(dict.fromkeys(packages))[:50]
